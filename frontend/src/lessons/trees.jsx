import Topbar from "../baza/Topbar";
import "../css/style.css";
import React from "react";
import MyTabs from "../baza/MyTabs";
import Question from "../baza/question";
import SyntaxHightlighterPython from "../baza/CodeBlocksPython";
import Article from "../baza/CreateArticle";
import dr1 from '../pics/dr1.png'
import dr2 from '../pics/dr2.png'
import dr3 from '../pics/dr3.png'
import dr4 from '../pics/dr4.png'
import dr5 from '../pics/dr5.png'
import dr6 from '../pics/dr6.png'
import dr7 from '../pics/dr7.png'
import dr8 from '../pics/dr8.png'
import dr9 from '../pics/dr9.png'
import dr10 from '../pics/dr10.png'
import dr11 from '../pics/dr11.png'
import dr12 from '../pics/dr12.png'
import dr13 from '../pics/dr13.png'
import dr14 from '../pics/dr14.png'
import dr15 from '../pics/dr15.png'
import dr16 from '../pics/dr16.png'
import dr17 from '../pics/dr17.png'
import dr18 from '../pics/dr18.png'
import dr19 from '../pics/dr19.png'
import dr20 from '../pics/dr20.png'
import dr21 from '../pics/dr21.png'
import dr22 from '../pics/dr22.png'
import dr23 from '../pics/dr23.png'


const code1 = `void dfs(int s, int e) {
  //	обработать	вершину	s
    for (auto u : adj[s]) {
    if (u != e) dfs(u, s);
}`;
const code2 = `void dfs(int s, int e) {
  count[s] = 1;
  for (auto u : adj[s]) {
    if (u == e) continue;
    dfs(u, s);
    count[s] += count[u];
  }
}`
const code3 = `depth(a) + depth(b) − 2 · depth(c),`
const code4 = `swap(a,b);`

const Trees = () => {
  return (
    <div>
      <Topbar></Topbar>

      <div style={{ maxWidth: 950, textAlign: "left", margin: "0 auto" }}>
        <h1 style={{ maxWidth: 950, marginBottom: 0, marginTop: 40 }}>Темы:</h1>
      </div>

      <div className="main__cont">
        <MyTabs themes={[`Базовые понятия`, `Обход дерева`, `Вычисление диаметра`, `Нахождение предков`, `Поддеревья и пути`, `Наименьшие общие предки`, `Объединение структур данных`, `Центроидная декомпозиция`, `Heavy-light декомпозиция`,]}>



          <Article data={[
            [`Базовые понятия`, 'h1'],
            [`Рассмотрим дерево, изображенное на рисунке. В нем 8 вершин и 7 ребер, листьями являются вершины 3, 5, 7 и 8.`, 'p'],
            [dr1, 'img'],
            [`В корневом дереве одна из вершин считается корнем дерева, а все остальные располагаются под ней. Вершины, расположенные непосредственно под некоторой вершиной, называются ее дочерними вершинами, а вершина, расположенная непосредственно над некоторой вершиной, – ее
            родителем. У каждой вершины, кроме корня,
            имеется ровно один родитель. У корня родителя
            нет. Корневое дерево имеет рекурсивную структуру: каждая вершина играет роль корня поддерева, содержащего эту вершину и все вершины,
            принадлежащие поддеревьям ее дочерних вершин.`, 'p'],
            [`На рисунке показано корневое дерево с корнем в вершине 1. Дочерними для вершины 2 являются вершины 5 и 6, а родителем вершины 2 –
            вершина 1. Поддерево вершины 2 состоит из
            вершин 2, 5, 6 и 8.
            `, 'p'],
            [dr2, 'img'],
            
          ]}/>


          <Article data = {[
            [`Обход дерева`, 'h1'],
            [`Для обхода вершин дерева применимы общие алгоритмы обхода графов. Однако обход дерева реализовать проще, чем в общем случае, поскольку в нем нет циклов и невозможно попасть в вершину с нескольких
            направлений.`, 'p'],
            [`Чаще всего для обхода дерева применяют поиск в глубину, начиная с
            произвольной вершины. Можно использовать следующую рекурсивную
            функцию:`, 'p'],
            [code1, 'code'],
            [`Функции передаются два параметра: текущая вершина s и предыдущая вершина e. Параметр e гарантирует, что далее будут просматриваться
            только еще не посещенные вершины.
            `, 'p'],
            [`При таком вызове поиск начинается с вершины x:
            dfs(x, 0);
            `, 'p'],
            [`При первом вызове функции e = 0, поскольку предыдущей вершины еще
            нет, и, следовательно, разрешено двигаться по дереву в любом направлении.`, 'p'],
            [`Динамическое программирование можно использовать для вычисления некоторой информации в процессе обхода дерева. Показанный ниже код для каждой вершины s вычисляет count[s] – количество вершин в
            ее поддереве. Поддерево содержит саму вершину и все вершины, принадлежащие поддеревьям ее дочерних вершин, поэтому количество вершин
            можно вычислить рекурсивно:`, 'p'],
            [code2, 'code'],
            [`Обход двоичного дерева`, 'h1'],
            [`В двоичном дереве каждая вершина имеет
            левое и правое поддеревья (возможно, пустые). Существует три распространенных способа обхода двоичных деревьев:`, 'p'],
            [[
              `прямой порядок: сначала обрабатывается корневая вершина, после
              чего обходится левое, а затем правое поддерево;`,
              `внутренний порядок: сначала обходится левое поддерево, затем обрабатывается корневая вершина, потом обходится правое поддерево;`,
              `обратный порядок: сначала обходится левое поддерево, затем правое поддерево, потом обрабатывается корневая вершина.
              `,
            ], 'ul'],
            [`Для дерева на рисунке прямым порядком будет [1, 2, 4, 5, 6, 3, 7], внутренним – [4, 2, 6, 5, 1, 3, 7], а обратным – [4, 6, 5, 2, 7, 3, 1].`, 'p'],
            [dr3, 'img'],
            
           
          ]}/>


          <Article data = {[
            
            [`Вычисление диаметра`, 'h1'],
            [`Диаметром дерева называется максимальная длина пути между двумя
            его вершинами. На рисунке изображено дерево диаметра 4, которому соответствует путь длины 4 между вершинами 6 и 7. Отметим, что в этом
            дереве есть и другой путь длины 4 между вершинами 5 и 7.`, 'p'],
            [dr4, 'img'],
            [`Ниже мы обсудим два алгоритма вычисления диаметра дерева с временной сложностью O(n). Первый основан на динамическом
            программировании, во втором используется
            поиск в глубину`, 'p'],
            [`Общий подход к задачам о деревьях заключается в том, чтобы сначала произвольным образом
            выбрать корень, а затем решить задачу отдельно для каждого поддерева.
            На этой идее основан первый алгоритм вычисления диаметра.`, 'p'],
            [`Сделаем важное наблюдение: на каждом пути
            в корневом дереве имеется высшая точка. Таким
            образом, для каждой вершины x мы можем вычислить длину самого длинного пути с высшей
            точкой x. Один из таких путей соответствует диаметру дерева. На рисунке высшей точкой пути,
            соответствующей диаметру, является вершина 1.`, 'p'],
            [dr5, 'img'],
            [`Для каждой вершины x мы вычислим два значения:`, 'p'],
            [[
              ` toLeaf(x): максимальная длина пути от x до листа;`,
              ` maxLength(x): максимальная длина пути с высшей точкой x`,
            ], 'ul'],
            [`Чтобы вычислить эти значения для всех вершин за время O(n), можно
            воспользоваться динамическим программированием. Сначала для вычисления toLeaf(x) мы переберем дочерние вершины x, выберем из них
            вершину c с максимальным значением toLeaf(c) и прибавим к этому значению 1. Затем для вычисления maxLength(x) мы выберем две различные
            дочерние вершины a и b – такие, что сумма toLeaf(a) + toLeaf(b) максимальна, и прибавим к этой сумме 2. (Случаи, когда у x меньше двух дочерних вершин, особые, но они легко разбираются.)
            `, 'p'],
            [`Еще один эффективный способ вычислить диаметр
            дерева основан на поиске в глубину. Сначала выберем в дереве произвольную вершину a и найдем вершину b, самую
            далекую от a. Затем найдем вершину c, самую далекую от b. Диаметр дерева равен расстоянию между b и c.`, 'p'],
            [`На рисунке показан один из способов выбора вершин a, b и c при вычислении диаметра дерева.`, 'p'],
            [dr6, 'img'],
            [`Это элегантный метод, но почему он дает правильный результат? Полезно нарисовать дерево так, чтобы путь, реализующий диаметр, был расположен горизонтально, а остальные вершины «свисали» с него.
            Буквой x обозначено место, в котором путь из вершины a соединяется с
            путем, реализующим диаметр. Самая далекая от a вершина – это b, c или
            еще какая-то вершина, отстоящая от x на такое же или большее расстояние. Таким образом, эту вершину всегда можно выбрать в качестве конечной точки пути, реализующего диаметр.
            `, 'p'],
            [dr7, 'img'],
            
          ]}/>



          <Article data = {[
            [`Нахождение предков`, 'h1'],
            [`k-м предком вершины x корневого дерева
            называется вершина, в которую мы попадем,
            поднявшись на k уровней вверх от x. Обозначим ancestor(x, k) k-го предка вершины x (или 0,
            если такого предка не сущест вует). На рисунке
            ancestor(2, 1) = 1, а ancestor(8, 2) = 4.
            `, 'p'],
            [dr8, 'img'],
            [`Вычислить ancestor(x, k) проще всего, последовательно выполнив k шагов по дереву. Но временная сложность этого метода равна O(k), что
            может оказаться медленно, поскольку в дереве
            с n вершинами может встретиться путь длины n.`, 'p'],
            [`К счастью, значение ancestor(x, k) для любой вершины x можно вычислить за время O(log k) после предобработки. Как и в разделе 7.5.1,
            идея заключается в том, чтобы предварительно вычислить все значения
            ancestor(x, k) для случаев, когда k – степень двойки. Для дерева, изображенного на рисунке, получаем:`, 'p'],
            [dr9, 'img'],
            [`Поскольку у любой вершины заведомо меньше n предков, достаточно
            вычислить O(log n) значений для каждой вершины, так что предобработка
            займет время O(n log n). После этого любое значение ancestor(x, k) можно
            будет вычислить за время O(log k), представив k в виде суммы степеней
            двойки`, 'p'],
            
          ]}/>



          <Article data = {[
            [`Поддеревья и пути`, 'h1'],
            [`Массив обхода дерева содержит вершины корневого дерева в порядке их
            посещения в процессе поиска в глубину из корня. На рисунке показаны
            дерево и массив обхода для него`, 'p'],
            [dr10, 'img'],
            [`У массива обхода дерева есть важное свойство: каждому поддереву соответствует его подмассив, первым элементом которого является корень
            этого поддерева. На рисунке показан подмассив, соответствующий поддереву вершины 4.`, 'p'],
            [dr11, 'img'],
            [`Запросы о поддеревьях`, 'h3'],
            [`Предположим, что каждой вершине дерева
            сопоставлено некоторое значение, и наша задача – обработать запросы
            двух типов: изменить значение в вершине и вычислить сумму значений
            в поддереве вершины. Для решения этой задачи мы построим массив обхода дерева, содержащий три значения для каждой вершины: ее идентификатор, размер поддерева и значение в вершине. На рисунке показаны
            дерево и соответствующий ему массив.`, 'p'],
            [dr12, 'img'],
            [`Пользуясь этим массивом, мы можем вычислить сумму значений в
            любом поддереве. Для этого нужно сначала определить размер поддерева, а затем просуммировать значения в соответствующих вершинах. На
            рисунке показано, к каким значениям мы обращаемся при вычислении
            суммы значений в поддереве вершины 4. Из последней строки массива
            видно, что сумма значений равна 3 + 4 + 3 + 1 = 11.
            `, 'p'],
            [dr13, 'img'],
            [`Для эффективного ответа на такие запросы достаточно сохранить последнюю строку массива в двоичном индексном дереве или в дереве отрезков. После этого мы сможем изменять значение и вычислять сумму
            значений за время O(log n).`, 'p'],
            [`Запросы о путях`, 'h3'],
            [`С помощью массива обхода дерева мы можем эффективно вычислять суммы значений на путях из корня в любую вершину дерева. Рассмотрим, например, обработку запросов двух типов: изменение значения в вершине и вычисление суммы значений на пути из корня
            в вершину.`, 'p'],
            [`в вершину.
            Для решения этой задачи мы построим массив обхода дерева, в котором
            для каждой вершины будут храниться ее идентификатор, размер поддерева и сумма значений на пути от корня к этой вершине. Если
            значение в некоторой вершине увеличивается на x, то суммы для всех вершин, принадлежащих ее поддереву, тоже увеличиваются на x. На рисунке
            показано, как будет выглядеть массив после увеличения значения в вершине 4 на 1.
            `, 'p'],
            [dr14, 'img'],
            [`Чтобы поддержать обе операции, мы должны уметь увеличивать все
            значения в диапазоне и получать одно значение. Это можно сделать за
            время O(log n) с помощью двоичного индексного дерева или дерева отрезков.`, 'p'],
            
          ]}/>



          <Article data = {[
            [`Наименьшие общие предки`, 'h1'],
            [`Наименьшим общим предком двух вершин корневого дерева называется самая низко расположенная вершина, поддерево которой содержит обе
            эти вершины. Так, на рис. 10.19 наименьшим общим предком вершин 5 и 8
            является вершина 2.`, 'p'],
            [dr15, 'img'],
            [`Эффективный поиск наименьшего общего
            предка двух вершин – часто встречающаяся задача. Мы обсудим два способа ее решения.`, 'p'],
            [`Первый метод`, 'h3'],
            [`Поскольку мы умеем эффективно находить k-й предок любой вершины дерева, то можем воспользоваться этим для разбиения задачи на две части. Нам понадобятся
            два указателя, первоначально направленных на
            вершины, для которых мы ищем наименьший
            общий предок.
            `, 'p'],
            [`Сначала проверим, что вершины, на которые
            направлены указатели, расположены на одном
            уровне дерева. Если это не так, сдвинем один из
            указателей вверх. После этого определим, какое
            минимальное число сдвигов обоих указателей вверх необходимо, чтобы
            они оказались направлены на одну и ту же вершину. Эта вершина и будет
            наименьшим общим предком. Поскольку обе части алгоритма можно выполнить за время O(log n), если воспользоваться предварительно вычисленной информацией, то наименьший общий предок любых двух вершин
            можно найти за время O(log n).`, 'p'],
            [`На рис. 10.20 показано, как найти наименьший общий предок вершин
            5 и 8 в рассматриваемом примере. Сначала мы сдвигаем второй указатель
            на один уровень вверх, так что вершина 6, на которую он указывает, находится на том же уровне, что и вершина 5. Затем после сдвига обоих указателей на один шаг вверх они указывают на вершину 2, которая и является
            наименьшим общим предком.`, 'p'],
            [dr16, 'img'],
            [`Второй метод`, 'h3'],
            [`Другой способ решения этой задачи был предложен в работе Bender, Farach-Colton [3]. Он основан на расширенном массиве обхода
            дерева, который всегда называют эйлеровым обходом дерева. Для построения массива мы обходим вершины дерева, применяя поиск в глубину,
            и добавляем вершину в массив при каждом ее прохождении (а не только
            при первом посещении). Поэтому вершина, имеющая k дочерних вершин,
            встретится в массиве k + 1 раз, а всего в нем будет 2n − 1 элементов. В каждом элементе массива хранятся два значения: идентификатор вершины и
            ее глубина в дереве. На рис. 10.21 показан массив, соответствую щий дереву из рассматриваемого примера.`, 'p'],
            [dr17, 'img'],
            [`Теперь можно найти наименьший общий предок вершин a и b, отыскав
            вершину с минимальной глубиной, находящуюся между вершинами a и b
            в массиве. На рис. 10.22 показано, как ищется наименьший общий предок вершин 5 и 8. Вершина с минимальной глубиной, находящаяся между
            ними, – это вершина 2 глубины 2, поэтому она и является наименьшим
            общим предком.`, 'p'],
            [dr18, 'img'],
            [`Отметим, что поскольку одна вершина может встречаться в массиве
            несколько раз, возможно несколько способов выбрать промежуток между
            вершинами a и b. Но при любом выборе наименьший общий предок определяется правильно.`, 'p'],
            [`При использовании этой техники для нахождения наименьшего общего
            предка двух вершин достаточно обработать запрос о минимуме по диапазону. Стандартный способ обработки таких запросов с помощью дерева
            отрезков имеет временную сложность O(log n). Но, поскольку массив статический, мы можем отвечать на них и за время O(1) после предобработки,
            занимающей время O(n log n).`, 'p'],
            [`Вычисление расстояний`, 'h3'],
            [`Наконец, рассмотрим задачу о вычислении
            расстояния между вершинами a и b (т. е. длины пути между ними). Оказывается, что ее можно свести к задаче о нахождении наименьшего общего предка. Сначала произвольным образом
            выберем корень дерева. Тогда расстояние между вершинами a и b можно будет вычислить по
            формуле`, 'p'],
            [code3, 'code'],
            [`где c – наименьший общий предок a и b.`, 'p'],
            [`Чтобы вычислить расстояние между вершинами 5 и 8 на рис. 10.23, мы сначала находим
            их наименьший общий предок – вершину 2.
            Затем, поскольку глубины вершин depth(5) = 3,
            depth(8) = 4 и depth(2) = 2, то расстояние между
            вершинами 5 и 8 равно 3 + 4 − 2 · 2 = 3.`, 'p'],
            [dr19, 'img'],
            
          ]}/>





          <Article data={[
            [`Объединение структур данных`, 'h1'],
            [`До сих пор мы рассматривали оперативные алгоритмы обработки запросов к дереву. Они позволяют обрабатывать запросы один за другим,
            так что ответ на предыдущий запрос дается до получения следующего. Но
            существует много задач, когда свойство оперативности необязательно и
            можно воспользоваться пакетными алгоритмами. Такому алгоритму передается весь набор запросов, и он вправе обрабатывать их в любом порядке.
            Зачастую спроектировать пакетный алгоритм проще, чем оперативный.`, 'p'],
            [`Один из способов проектирования пакетного алгоритма состоит в том,
            чтобы выполнить обход дерева в глубину и создать в вершинах некоторые
            структуры данных. В каждой вершине s создается структура данных d[s],
            основанная на структурах данных в дочерних вершинах s. Эта структура
            данных позволяет обрабатывать все запросы, относящиеся к s.
            `, 'p'],
            [`В качестве примера рассмотрим следующую задачу: дано корневое дерево, с каждой вершиной которого ассоциировано некоторое значение.
            Требуется отвечать на запросы о том, сколько вершин со значением x имеется в поддереве вершины s. На рис. 10.24
            поддерево вершины 4 содержит две вершины со значением 3.
            `, 'p'],
            [dr20, 'img'],
            [`Для ответа на такие запросы можно
            воспользоваться структурой отображения
            (значения на число вершин с таким значением). На рис. 10.25 показаны отображения
            для вершины 4 и ее дочерних вершин. Создав такую структуру данных для каждой
            вершины, мы легко сможем обработать
            все запросы, поскольку на запрос, относящийся к определенной вершине, можно отвечать сразу после создания структуры данных для нее. Но создавать все
            структуры с нуля было бы слишком медленно. Вместо этого мы создадим
            в каждой вершине s начальную структуру данных d[s], содержащую только
            значение, ассоциированное с s. После этого мы пробежимся по дочерним
            вершинам s и объединим d[s] и все структуры d[u], где u – дочерняя вершина s. Например, в дереве из нашего примера отображение для вершины 4
            создано путем объединения отображений на рис. 10.26, где первое отображение – начальная структура данных для вершины 4, а остальные три
            соответствуют вершинам 7, 8 и 9.`, 'p'],
            [dr21, 'img'],
            [`Объединение в вершине s выполняется следующим образом: перебираем все дочерние вершины s и в каждой вершине u объединяем d[s] с d[u].
            Мы всегда копируем содержимое d[u] в d[s]. Но предварительно содержимое d[s] и d[u] обменивается, если d[s] меньше d[u]. В результате каждое
            значение копируется всего O(log n) раз в процессе обхода дерева, что гарантирует эффективность алгоритма.`, 'p'],
            [`Для эффективного обмена структур данных a и b можно использовать
            такой код:`, 'p'],
            [code4, 'code'],
            [`Гарантируется, что он работает за постоянное время, если a и b – структуры данных из стандартной библиотеки C++.
            `, 'p'],
            
          ]}/>




          <Article data = {[
            [`Центроидная декомпозиция`, 'h1'],
            [`Центроидом дерева с n вершинами называется такая вершина, удаление
            которой разбивает дерево на поддеревья, каждое из которых содержит не
            более ⌊n/2⌋ вершин. В каждом дереве существует центроид; чтобы его найти, нужно выбрать произвольный корень и всегда переходить в поддерево с максимальным числом вершин до тех пор, пока текущая вершина не
            окажется центроидом.`, 'p'],
            [`В методе центроидной декомпозиции мы сначала находим центроид
            дерева и обрабатываем все проходящие через него пути. После этого центроид удаляется, а оставшиеся поддеревья обрабатываются рекурсивно.
            Поскольку удаление центроида оставляет поддеревья, размер которых не
            превосходит половины размера исходного дерева, временная сложность
            такого алгоритма равна O(n log n), при условии что время обработки каждого поддерева линейно.
            `, 'p'],
            [`На рис. 10.27 показан первый шаг алгоритма центроидной декомпозиции. В этом дереве вершина 5 является единственным центроидом, поэтому сначала обрабатываются
            пути, проходящие через вершину 5. Затем эта
            вершина удаляется из дерева, и рекурсивно
            обрабатываются три поддерева: {1, 2}, {3, 4} и
            {6, 7, 8}.`, 'p'],
            [dr22, 'img'],
            [`С помощью центроидной декомпозиции
            мы, например, можем эффективно вычислить количество путей длины x в дереве. Для
            этого мы сначала находим центроид и вычисляем количество путей, проходящих через него. Это можно сделать за линейное время. Затем удаляем
            центроид и рекурсивно обрабатываем меньшие деревья. Временная сложность алгоритма равна O(n log n).`, 'p'],
            
          ]}/>


        <Article data = {[
                    [`Heavy-light декомпозиция`, 'h1'],
                    [`При heavy-light декомпозиции (heavy-light decomposition)1
                    множество
                   вершин дерева разбивается на множество тяжелых (heavy) путей. Тяжелые пути создаются таким образом, что на пути между любыми двумя
                   вершинами находится O(log n) подпутей, являющихся тяжелыми путями.
                   Благодаря этой технике мы можем манипулировать вершинами на путях
                   между вершинами дерева почти как элементами массива, добавляя лишь
                   коэффициент порядка O(log n).`, 'p'],
                    [`Для построения тяжелых путей мы сначала произвольным образом выбираем корень дерева. Первый тяжелый путь начинается в корне и всегда идет в вершину, для которой размер поддерева
                    максимален. Затем рекурсивно обрабатываются
                    остальные поддеревья. На рис. 10.28 показано
                    четыре тяжелых пути: 1–2–6–8, 3, 4–7 и 5 (два из
                    них состоят всего из одной вершины).`, 'p'],
                    [`Теперь рассмотрим какой-нибудь путь между
                    двумя вершинами дерева. Поскольку при создании тяжелых путей всегда выбиралось поддерево
                    максимального размера, то мы заведомо сможем
                    разбить путь на O(log n) подпутей, каждый из которых является подпутем единственного тяжелого пути. На рис. 10.28 путь между вершинами 7
                    и 8 можно разбить на два тяжелых подпути: 7–4,
                    затем 1–2–6–8.`, 'p'],
                    [dr23, 'img'],
                    [`Достоинство heavy-light декомпозиции состоит в том, что каждый тяжелый путь можно рассматривать как массив вершин. Например, с каждым
                    тяжелым путем можно сопоставить дерево отрезков и поддержать сложные запросы о путях, например вычисление максимального значения
                    вершины на пути или увеличение значения, ассоциированного с каждой
                    вершиной на пути. Такие запросы можно обработать за время O(log^2 n)^2
                    ,
                    поскольку каждый путь состоит из O(log n) тяжелых путей, а каждый тяжелый путь можно обработать за время O(log n).`, 'p'],
                    [`Хотя с помощью heavy-light декомпозиции можно решить много задач,
                    следует помнить, что часто существует другое решение, реализовать которое проще. В частности, вместо heavy-light декомпозиции нередко можно
                    использовать методы, описанные ранее.
                    `, 'p'],
                    
                  ]}/>
          
        </MyTabs>
      </div>
    </div>
  );
};

export default Trees;
