import Topbar from "../baza/Topbar";
import "../css/style.css";
import React from "react";
import MyTabs from "../baza/MyTabs";
import Question from "../baza/question";
import SyntaxHightlighterPython from "../baza/CodeBlocksPython";

const fibonacciMemoization = `
# Вычисление n-ого числа Фибоначчи с помощью мемоизации

# В данном словаре будут хранится результаты вызова функции \`fib\`
mem_table = {}
    
def fib(n):
    if n == 1 or n == 2:
        return 1
        
    if not n in mem_table:
        # Если до этого мы не считали результат \`fib\` для n
        # то добавляем этот результат в таблицу мемоизации
        mem_table[n] = fib(n - 1) + fib(n - 2) 

    return mem_table[n]
`;

const fibonacciInbuiltMemoization = `
# Вычисление n-ого числа с помощью встроенной в Python мемоизации

import functools

# functools.cache предоставляет специальный декоратор для эффективной мемоизации функций
# однако для его работы требуется, чтобы ВСЕ аргументы функции могли быть хэшируемыми
# Например: list не хэшируется, вместо него необходимо использовать tuple
@functools.cache
def fib(n):
    if n == 1 or n == 2:
        return 1
        
    return fib(n - 1) + fib(n - 2)
`;

const linkedList = `
// Ячейка связанного списка
struct linked_list_node {
    // Указатель на следующую ячейку в связанном списке
    struct linked_list_node* next;
        
    // Некоторые данные, хранящиеся в каждой ячейке
    int data; 
}

    
// Связанный список
struct linked_list {
    // Указатель на начало списка
    struct linked_list_node* head;
        
    // Длинна списка
    size_t length;
}
`;

const zeroOneKnapsack = `
# Подсчитывает цену всех текущих предметов с условием, что их вес не превышает максимальный
def total_value(items, max_weight):
    return sum([x[2] for x in items]) if sum([x[1] for x in items]) <= max_weight else 0
 
# Таблица мемоизации
cache = {}

def solve(items, max_weight):
    # Если список предметов пуст, то оптимальный расклад - пустой кортеж
    if not items:
        return ()

    # Иначе рекурсивно вычисляем оптимальный расклад
    if (items, max_weight) not in cache:
        head = items[0]
        tail = items[1:]
        include = (head,) + solve(tail, max_weight - head[1])
        dont_include = solve(tail, max_weight)

        if total_value(include, max_weight) > total_value(dont_include, max_weight):
            answer = include
        else:
            answer = dont_include

        # Не забываем мемоизировать результаты вычислений
        cache[(items,max_weight)] = answer

    return cache[(items,max_weight)]
 
# Предметы формата (название, вес, цена)
items = (
    ("map", 9, 150), ("compass", 13, 35), ("water", 153, 200), ("sandwich", 50, 160),
    ("glucose", 15, 60), ("tin", 68, 45), ("banana", 27, 60), ("apple", 39, 40),
    ("cheese", 23, 30), ("beer", 52, 10), ("suntan cream", 11, 70), ("camera", 32, 30),
    ("t-shirt", 24, 15), ("trousers", 48, 10), ("umbrella", 73, 40),
    ("waterproof trousers", 42, 70), ("waterproof overclothes", 43, 75),
    ("note-case", 22, 80), ("sunglasses", 7, 20), ("towel", 18, 12),
    ("socks", 4, 50), ("book", 30, 10),
    )
max_weight = 400
solution = solve(items, max_weight)

print("items:")
for x in solution:
    print(x[0])
print("value:", total_value(solution, max_weight))
print("weight:", sum([x[1] for x in solution]))
`;

const longestCommonSubsequence = `
def lcs(seq1, seq2):
    # Здесь создаётся матрица, хранящая длины наибольших подпоследоваетльностей на определённых индексах seq1 и seq2
    lens = [[0] * (len(seq2)+1) for _ in range(len(seq1)+1)]

    # Производим полный перебор каждых двух позиций в seq1 и seq2
    for i, x in enumerate(seq1):
        for j, y in enumerate(seq2):
            if x == y:
                lens[i+1][j+1] = lens[i][j] + 1
            else:
                lens[i+1][j+1] = max(lens[i+1][j], lens[i][j+1])

    # Считываем результат в res
    res = []
    j = len(seq2)
    for i in range(1, len(seq1) + 1):
        if lens[i][j] != lens[i-1][j]:
            res.append(seq1[i-1])
            
    return res


s1 = [1, 6, 2, 1, 7, 8]
s2 = [3, 6, 4, 2, 9, 11, 7]

print(lcs(s1, s2))
`;

const DP = () => {
  return (
    <div>
      <Topbar></Topbar>

      <div style={{ maxWidth: 950, textAlign: "left", margin: "0 auto" }}>
        <h1 style={{ maxWidth: 950, marginBottom: 0, marginTop: 40 }}>Темы:</h1>
      </div>

      <div className="main__cont">
        <MyTabs
          themes={[
            "Основные понятия",
            "Мемоизация",
            "Рекурсия",
            "Задача о рюкзаке",
            "Задача о наибольшей общей подпоследовательности",
          ]}
        >
          <div className="flex__cont__for__articles">
            <div className="article">
              <div className="text">
                <h1>Основные понятия</h1>
                <p>
                  Динамическое программирование - способ решения сложных задач
                  путём разбиения их на более простые подзадачи. Этот способ в
                  основном применяется к задачам, которые можно явно разделить
                  на конкретные подчасти, покрывающие своим решением всю задачу.
                </p>
                <p>
                  Как правило, результаты выполнения этих "подчастей"
                  объединяются с помощью некого алгоритма, в результате которого
                  получается решение.
                </p>

                <h1>Основная идея</h1>
                <p>
                  Оптимальная подструктура в динамическом программировании
                  означает, что оптимальное решение подзадач меньшего размера
                  может быть использовано для решения исходной задачи. К
                  примеру, кратчайший путь в графе из одной вершины (обозначим
                  s) в другую (обозначим t) может быть найден так: сначала
                  считаем кратчайший путь из всех вершин, смежных с s, до t, а
                  затем, учитывая веса рёбер, которыми s соединена со смежными
                  вершинами, выбираем лучший путь до t (через какую вершину
                  лучше всего пойти).
                </p>
                <p>
                  В общем случае мы можем решить задачу, в которой присутствует
                  оптимальная подструктура, проделывая следующие три шага.
                  Разбиение задачи на подзадачи меньшего размера. Нахождение
                  оптимального решения подзадач рекурсивно, проделывая такой же
                  трехшаговый алгоритм. Использование полученного решения
                  подзадач для конструирования решения исходной задачи.
                  Подзадачи решаются делением их на подзадачи ещё меньшего
                  размера и т. д., пока не приходят к тривиальному случаю
                  задачи, решаемой за константное время (ответ можно сказать
                  сразу). К примеру, если нам нужно найти n!, то тривиальной
                  задачей будет 1! = 1 (или 0! = 1).
                </p>

                <h1>Примеры задач</h1>
                <p>
                  <ul>
                    <li>
                      <a
                        className="link"
                        href="https://en.wikipedia.org/wiki/Knapsack_problem"
                      >
                        Задача о рюкзаке (Knapsack problem)
                      </a>
                    </li>

                    <li>
                      <a
                        className="link"
                        href="https://en.wikipedia.org/wiki/Fibonacci_number"
                      >
                        Задача о вычислении чисел Фибоначчи
                      </a>
                    </li>

                    <li>
                      <a
                        className="link"
                        href="https://en.wikipedia.org/wiki/Matrix_chain_multiplication"
                      >
                        Задача о порядке перемножения матриц (Matrix chain
                        multiplication)
                      </a>
                    </li>

                    <li>
                      <a
                        className="link"
                        href="https://en.wikipedia.org/wiki/Longest_common_subsequence"
                      >
                        Задача о набольшей общей подпоследовательности (Longest
                        common subsequence)
                      </a>
                    </li>
                  </ul>
                </p>
              </div>
            </div>
          </div>

          <div>
            <div className="flex__cont__for__articles">
              <div className="article">
                <div className="text">
                  <h1>Основные понятия</h1>
                  <p>
                    Меомизация (от англ. "memory" - память и "optimization" -
                    оптимизация) - сохранение результатов выполнения функций
                    (или других исполняемых объектов) для последующего
                    использования в прогамме.
                  </p>
                  <p>
                    Позволяет за счёт использования памяти ускорить выполнение
                    программы. Часто применяется в динамическом программировании
                    для хранения промежуточных данных.
                  </p>

                  <h1>Примеры</h1>
                  <p>Все примеры приведены на языке программирования Python.</p>
                  <SyntaxHightlighterPython code={fibonacciMemoization} />
                  <SyntaxHightlighterPython
                    code={fibonacciInbuiltMemoization}
                  />
                </div>
              </div>
            </div>
          </div>

          <div className="flex__cont__for__articles">
            <div className="article">
              <div className="text">
                <h1>Основные понятия</h1>
                <p>
                  Рекурсия - это определение некого объекта с помощью самого
                  себя. В программировании самые распространённые рекурсивные
                  объекты - функции, но бывают также и рекурсивные типы данных.
                </p>
                <p>
                  Как пример рекурсии можно привести функцию, вычисляющую числа
                  Фибоначчи, которая определяется следующим образом: fib(n) =
                  fib(n-1) + fib(n+2). Или же функцию вычисления факториала
                  числа, которая определена как fac(n) = n * fac(n-1). В обоих
                  случаях n - положительное целое число.
                </p>
                <p>
                  Эрудированный читатель может подметить, что для выполнения
                  "истинной" рекурсивной функции необходимо бесконечное
                  количество памяти. К сожалению, современные ЭВМ не обладают
                  такой роскошью, ввиду чего у каждой рекурсивной функции должно
                  быть хотя бы одно условие прекращения рекурсии. Это условие
                  называется "базовым случаем" рекурсии. Например, для
                  вышеперечисленных функций базовые случаи предоставляют из себя
                  следующее: fib(1) = 1, fib(2) = 1 и fac(0) = 1.
                </p>

                <Question
                  question={"Что должно быть у каждой рекурсивной функции?"}
                  answers={[
                    "основной случай",
                    "особый случай",
                    ["базовый случай", 1],
                    "базовая компонента",
                  ]}
                />

                <h1>В типах данных</h1>
                <p>
                  Как уже было выше сказанно, рекурсия может проявляться не
                  только в определении некоторых функций, но также и в
                  определении типов данных. В низкоуровневых языках
                  программирования эта рекурсия реализвана с помощью указателей
                  на тот же тип данных, который их содержит. Ниже приведён
                  пример реализации связанного списка на C/C++.
                </p>

                <SyntaxHightlighterPython code={linkedList} />
              </div>
            </div>
          </div>
          <div className="flex__cont__for__articles">
            <div className="article">
              <div className="text">
                <h1>Краткое определение</h1>
                <p>
                  В самом простом понимании "проблема о рюкзаке" (также
                  "проблема о ранце" или "knapsack problem") представляет из
                  себя следующее: перед вами имеется рюкзак с вместимостью C
                  у.е., а также N предметов, у каждого из которых есть объём V и
                  цена P; вам необходимо заполнить рюкзак так, чтобы сумма всех
                  P была максимальной, а сумма всех V не превышала C.
                </p>

                <p>
                  Эта проблема (и все её разновидности) - одна из самых
                  распространённых не только в информатике, но и в логистике,
                  криптографии и экономике. Скорее всего, и сам читатель не раз
                  с ней сталкивался.
                </p>

                <h1>Распространённые разновидности</h1>
                <p>
                  Ввиду большой популярности данной проблемы в разных областях
                  науки, учёные начали выделять некоторые повторяющиеся её
                  разновидности. Ниже приведены самые популярные из них, с
                  некоторыми пояснениями.
                  <ul>
                    <li>Рюкзак 0-1 - не более одного предмета каждого вида</li>
                    <li>
                      Ограниченный рюкзак - не более K предметов каждого вида
                    </li>
                    <li>
                      Неограниченный рюкзак - произвольное количество предметов
                      каждого вида
                    </li>
                    <li>И множество других..</li>
                  </ul>
                </p>

                <h1>Способы решения</h1>
                <p>
                  Наверное первое, что приходит в голову - перебрать все
                  возможные варианты "сбора рюкзака". И хотя такое решение будет
                  правильным, оно будет далеко не самым эффективным по времени.
                  Например, для того же рюкзака 0-1 подобный алгоритм будет
                  иметь сложность по времени O(2^n), где n - общее количество
                  предметов.
                </p>

                <p>
                  Можно заметить, что эта задача обладает всеми свойствами,
                  чтобы её можно было решить методом динамического
                  программирования. Именно такой метод является наиболее
                  популярным в решении данной задачи.
                </p>

                <p>
                  Ниже приведено решение задачи разновидности "Рюкзак 0-1". За
                  основу взят код с RosettaCode.{" "}
                  <a
                    className="link"
                    href="https://rosettacode.org/wiki/Knapsack_problem/0-1"
                  >
                    Найти его можно здесь.
                  </a>
                  <SyntaxHightlighterPython code={zeroOneKnapsack} />
                </p>
              </div>
            </div>
          </div>
          <div className="flex__cont__for__articles">
            <div className="article">
              <div className="text">
                <h1>Краткое определение</h1>
                <p>
                  Допустим у нас есть два списка, A и B, состоящих из целых
                  чисел: [1, 6, 2, 1, 7, 8] и [3, 6, 4, 2, 9, 11, 7]. Наибольшей
                  общей подпоследовательностью этих двух списков будет являться
                  список K, состоящий из таких элементов (k1, k2, k3.. kn), что
                  для i=1..n ki принадлежит как A, так и B. В нашем случае ответ
                  K = [2, 6, 7] (или любая перестановка K).
                </p>

                <p>
                  Существует задача, звучащая достаточно похоже на эту -{" "}
                  <a
                    className="link"
                    href="https://en.wikipedia.org/wiki/Longest_common_substring"
                  >
                    задача о наибольшей общей подстроке
                  </a>
                  . В этом разделе она разобрана не будет, но её также можно
                  решить путём динамического программирования.
                </p>

                <h1>Способы решения</h1>
                <p>
                  Как и в случае задачи с рюкзаком, задачу о наибольшей общей
                  подпоследовательности можно решить элементарным перебором. Но
                  как уже, скорее всего, догадывается читатель, это самый
                  неэффективный способ решения.
                </p>

                <p>
                  Ниже приведено одно из простейших решений с помощью
                  динамического программирования - через матрицу длин. За основу
                  взят код с RosettaCode.{" "}
                  <a
                    href="https://rosettacode.org/wiki/Longest_common_subsequence"
                    className="link"
                  >
                    Найти его можно здесь.
                  </a>
                </p>

                <SyntaxHightlighterPython code={longestCommonSubsequence} />
              </div>
            </div>
          </div>
        </MyTabs>
      </div>
    </div>
  );
};

export default DP;
