import Topbar from "../baza/Topbar";
import '../css/style.css'
import React from 'react';
import graph1 from '../pics/graph1.png'
import hlst from '../pics/half_stepeni.png'
import anim from '../pics/Dijkstra_Animation.gif'
import bellman from '../pics/bellman.png'
import fl1 from '../pics/fl1.png'
import fl2 from '../pics/fl2.png'
import fl3 from '../pics/fl3.png'
import fl4 from '../pics/fl4.png'
import fl5 from '../pics/fl5.png'
import fl6 from '../pics/fl6.png'
import kr1 from '../pics/kr1.png'
import kr2 from '../pics/kr2.png'
import kr3 from '../pics/kr3.png'
import kr4 from '../pics/kr4.png'
import kr5 from '../pics/kr5.png'
import tp1 from '../pics/tp.png'
import tp2 from '../pics/tp2.png'
import prime from '../pics/prime.png'
import depth_search from '../pics/DepthFirstSearchTimestampsRu.svg.png'
import MyTabs from "../baza/MyTabs";
import Question from "../baza/question";
import SyntaxHightlighterCPP from "../baza/CodeBlocksCPP";
import { Light as SyntaxHighlighter } from 'react-syntax-highlighter';
import cpp from 'react-syntax-highlighter/dist/esm/languages/hljs/cpp'
SyntaxHighlighter.registerLanguage('cpp', cpp);

const code1 = `vector<int> adj[N];
`
const code2 = `vector<pair<int,int>> adj[N];
`
const code3 = `for (auto u : adj[s]) {
    //	обработать	вершину	u
}
`
const code4 = `int adj[N][N];
`
const code5 = `vector<pair<int,int>> edges;
`
const code6 = `vector<tuple<int,int,int>> edges;`

const code7 = `vector<int> adj[N];`
const code8 = `bool visited[N];
`
const code9 = `void dfs(int s) {
    if (visited[s]) return;
    visited[s] = true;
    //	обработать	вершину	s
    for (auto u: adj[s]) {
        dfs(u);
    }
}
   `
const code10 = `def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)

    print(start)

    for next in graph[start] - visited:
        dfs(graph, next, visited)
    return visited


graph = {'0': set(['1', '2']),
     '1': set(['0', '3', '4']),
     '2': set(['0']),
     '3': set(['1']),
     '4': set(['2', '3'])}

dfs(graph, '0')`
const code11 = `vector < vector<int> > g; // граф
int n; // число вершин
int s; // стартовая вершина (вершины везде нумеруются с нуля)

queue<int> q;
q.push (s);
vector<bool> used (n);
vector<int> d (n), p (n);
used[s] = true;
p[s] = -1;
while (!q.empty()) {
	int v = q.front();
	q.pop();
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (!used[to]) {
			used[to] = true;
			q.push (to);
			d[to] = d[v] + 1;
			p[to] = v;
		}
	}
}

`
const code12 = `graph = {
    '5' : ['3','7'],
    '3' : ['2', '4'],
    '7' : ['8'],
    '2' : [],
    '4' : ['8'],
    '8' : []
  }
  
  visited = [] # Список посещенных вершин
  queue = []     # Инициализация очереди
  
  def bfs(visited, graph, node): 
    visited.append(node)
    queue.append(node)
  
    while queue:          # Создание петли для посещений каждой вершины
      m = queue.pop(0) 
      print (m, end = " ") 
  
      for neighbour in graph[m]:
        if neighbour not in visited:
          visited.append(neighbour)
          queue.append(neighbour)
  
  print("Following is the Breadth-First Search")
  bfs(visited, graph, '5')    `
const code13 = `const int INF = 1000000000;
vector <int> dist(n, INF);
dist[start] = 0;
vector <bool> used(n);
int min_dist = 0;
int min_vertex = start;
while (min_dist < INF)
{
    int i = min_vertex;
    used[i] = true;
    for (int j = 0; j < n; ++j)
        if (dist[i] + w[i][j] < dist[j])
                dist[j] = dist[i] + w[i][j];
    min_dist = INF;
    for (int j = 0; j < n; ++j)
        if (!used[j] && dist[j] < min_dist)
        {
            min_dist = dist[j];
            min_vertex = j;
        }
}`
const code14 = `INF = 10 ** 10
dist = [INF] * n
dist[start] = 0
used = [False] * n
min_dist = 0
min_vertex = start
 while min_dist < INF:
    i = min_vertex 
    used[i] = True 
    for j in range(n): 
        if dist[i] + w[i][j] < dist[j]: 
            dist[j] = dist[i] + w[i][j] 
    min_dist = INF
    for j in range(n):
        if not used[j] and dist[j] < min_dist:
            min_dist = dist[j]
            min_vertex = j`
const code15 = `for (int i = 1; i <= n; i++) {
    distance[i] = INF;
}
distance[x] = 0;
for (int i = 1; i <= n-1; i++) {
    for (auto e : edges) {
    int a, b, w;
    tie(a, b, w) = e;
    distance[b] = min(distance[b], distance[a]+w);
}`
const code16 = `for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (i == j) dist[i][j] = 0;
        else if (adj[i][j]) dist[i][j] = adj[i][j];
        else dist[i][j] = INF;
    }
}

for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);
        }
    }
}`
const code17 = `1) D <--> B; w = 2
2) D <--> C; w = 6
3) A <--> B; w = 7
4) A <--> C; w = 8
5) C <--> E; w = 9
6) D <--> F; w = 9
7) F <--> E; w = 10
8) B <--> C; w = 11
9) D <--> E; w = 11`
const code18 = `vector<int> parent, rank;

void make_set(int v) {
    parent[v] = v;
    rank[v] = 0;
}

int find_set(int v) {
    if (v == parent[v])
        return v;
    return parent[v] = find_set(parent[v]);
}

void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (rank[a] < rank[b])
            swap(a, b);
        parent[b] = a;
        if (rank[a] == rank[b])
            rank[a]++;
    }
}

struct Edge {
    int u, v, weight;
    bool operator<(Edge const& other) {
        return weight < other.weight;
    }
};

int n;
vector<Edge> edges;

int cost = 0;
vector<Edge> result;
parent.resize(n);
rank.resize(n);
for (int i = 0; i < n; i++)
    make_set(i);

sort(edges.begin(), edges.end());

for (Edge e : edges) {
    if (find_set(e.u) != find_set(e.v)) {
        cost += e.weight;
        result.push_back(e);
        union_sets(e.u, e.v);
    }
}`
const code19 = `const int inf = 1000*1000*1000;


typedef vector<int> graf_line;
typedef vector<graf_line> graf;

typedef vector<int> vint;
typedef vector<vint> vvint;


int main()
{
	int n;
	cin >> n;
	vvint c (n, vint(n));
	for (int i=0; i<n; i++)
		for (int j=0; j<n; j++)
			cin >> c[i][j];
	// исток - вершина 0, сток - вершина n-1

	vvint f (n, vint(n));
	for (;;)
	{
		
		vint from (n, -1);
		vint q (n);
		int h=0, t=0;
		q[t++] = 0;
		from[0] = 0;
		for (int cur; h<t;)
		{
			cur = q[h++];
			for (int v=0; v<n; v++)
				if (from[v] == -1 &&
					c[cur][v]-f[cur][v] > 0)
				{
					q[t++] = v;
					from[v] = cur;
				}
		}

		if (from[n-1] == -1)
			break;
		int cf = inf;
		for (int cur=n-1; cur!=0; )
		{
			int prev = from[cur];
			cf = min (cf, c[prev][cur]-f[prev][cur]);
			cur = prev;
		}

		for (int cur=n-1; cur!=0; )
		{
			int prev = from[cur];
			f[prev][cur] += cf;
			f[cur][prev] -= cf;
			cur = prev;
		}

	}

	int flow = 0;
	for (int i=0; i<n; i++)
		if (c[0][i])
			flow += f[0][i];

	cout << flow;

}`
const code20 = `#include <iostream>
#include <vector>
using namespace std;
 
// Структура данных для хранения ребра Graph
struct Edge {
    int src, dest;
};
 
// Класс для представления graphического объекта
class Graph
{
public:
    // вектор векторов для представления списка смежности
    vector<vector<int>> adjList;
 
    // сохраняет степень вхождения вершины
    vector<int> indegree;
 
    // Конструктор Graphа
    Graph(vector<Edge> const &edges, int n)
    {
        // изменить размер вектора, чтобы он содержал 'n' элементов типа 'vector<int>'
        adjList.resize(n);
 
        // инициализируем входную степень
        vector<int> temp(n, 0);
        indegree = temp;
 
        // добавляем ребра в ориентированный graph
        for (auto &edge: edges)
        {
            // добавляем ребро от источника к месту назначения
            adjList[edge.src].push_back(edge.dest);
 
            // увеличиваем степень вхождения целевой вершины на 1
            indegree[edge.dest]++;
        }
    }
};
 
// Функция для выполнения топологической сортировки заданной DAG
vector<int> doTopologicalSort(Graph const &graph)
{
    vector<int> L;
 
    // получаем общее количество узлов в Graph
    int n = graph.adjList.size();
 
    vector<int> indegree = graph.indegree;
 
    // Набор всех узлов без входящих ребер
    vector<int> S;
    for (int i = 0; i < n; i++)
    {
        if (!indegree[i]) {
            S.push_back(i);
        }
    }
 
    while (!S.empty())
    {
        // удалить узел 'n' из 'S'
        int n = S.back();
        S.pop_back();
 
        // добавить 'n' в конце 'L'
        L.push_back(n);
 
        for (int m: graph.adjList[n])
        {
            // удаляем из Graph ребро от 'n' до 'm'
            indegree[m] -= 1;
 
            // если 'm' не имеет других входящих ребер, вставляем 'm' в 'S'
            if (!indegree[m]) {
                S.push_back(m);
            '
        }
    }
 
    // если в Graph есть ребра, то в Graph есть хотя бы один цикл
    for (int i = 0; i < n; i++)
    {
        if (indegree[i]) {
            return {};
        }
    }
 
    return L;
}
 
int main()
{
    // vector ребер Graph согласно схеме выше
    vector<Edge> edges =
    {
        { 0, 6 }, { 1, 2 }, { 1, 4 }, { 1, 6 }, { 3, 0 }, { 3, 4 },
        { 5, 1 }, { 7, 0 }, { 7, 1 }
    };
 
    // общее количество узлов в Graph (от 0 до 7)
    int n = 8;
 
    // строим graph из заданных ребер
    Graph graph(edges, n);
 
    // Выполняем топологическую сортировку
    vector<int> L = doTopologicalSort(graph);
 
    // вывести топологический порядок
    if (L.size()) {
        for (int i: L) {
            cout << i << " ";
        }
    } else {
        cout << "Graph has at least one cycle. Topological sorting is not possible";
    }
 
    return 0;
}`
const code21 = ``
const code22 = ``

const Graphs = () => {
    return (
    <div>
        <Topbar></Topbar>

        <div style={{ maxWidth: 950, textAlign: 'left', margin: '0 auto'}}>
                <h1 style={{ maxWidth: 950, marginBottom: 0, marginTop: 40}}>Темы:</h1>
        </div>

        <div className="main__cont">
                
                <MyTabs themes={['Приветствие', 'Основные понятия', 'Поиск в ширину', 'Поиск в глубину', 'Алгоритм Дейкстры',
                    'Алгоритм Беллмана-Форда', 'Алгоритм Флойда-Уоршелла ',
                    'Алгоритм Краскала', 'Алгоритм Прима', 'Топологическая сортировка', 'Алгоритм Эдмондса-Карпа'
                ]}>


                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <p>
                                Приветствуем, будущий олимпиадник! Если ты уже начал изучать программирование или только собираешься начать, то поздравляю, ты сделал очень правильный выбор! Олимпиадное программирование - это увлекательный и захватывающий мир, в котором ты сможешь проявить свои навыки и творческий потенциал.
                                </p>

                                <p>
                                Вместе с программированием ты научишься логическому мышлению, аналитической работе с данными, решению сложных задач и тому, как работать в команде.
                                </p>

                                <p>На пути к успеху тебя ждет много трудностей и вызовов, но это только укрепит твой дух и научит находить нестандартные решения. И помни: каждый раз, когда ты находишь решение сложной задачи, ты становишься лучше и сильнее!</p>

                                <p>Изучение олимпиадного программирования - это возможность не только стать успешным участником соревнований, но и получить ценный опыт, который пригодится в будущем как в карьере программиста, так и в обычной жизни. Поэтому не бойся сложностей и двигайся вперед к своим целям!</p>

                                <p>В этом и других блоках материалы взяты из книг "Спортивное программирование" Стивена Халима и Феликса Халима, "Олимпиадное программирование" Антти Лааксонена, а также с разлиных сайтов соответствующей тематики, википедии и из общедоступных конспектов студентов технических вузов.</p>
                            </div>
                        </div>
                    </div>

                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='1'>Определение графа</h2>
                                <img alt='' src={graph1} className="picture" ></img>

                                <p>
                                Термин «граф» неоднозначен и это легко обнаружить, сравнивая определения графа, приводимые в разных книгах по теории графов. Однако во всех этих определениях есть и общее. В любом случае граф состоит из двух множеств – множества вершин и множества ребер, причем для каждого ребра указана пара вершин, которые это ребро соединяет. Здесь будут рассматриваться только конечные графы, то есть такие, у которых оба множества конечны. Чтобы получить законченное определение графа того или иного типа, необходимо уточнить еще следующие три момента.
                                </p>

                                <h3>1. Ориентированный или неориентированный?</h3>
                                <p>
                                    Прежде всего нужно договориться, считаем ли мы пары (a, b) и (b, a) различными. Если да, то говорят, что рассматриваются упорядоченные пары (порядок элементов в паре важен), если нет – неупорядоченные. Если ребро e соединяет вершину a с вершиной b и пара считается упорядоченной, то это ребро называется ориентированным, вершина a – его началом, вершина b – концом. Если же эта пара считается неупорядоченной, то ребро называется неориентированным, а обе вершины – его концами. Заметим, что неориентированное ребро, соединяющее a с b, соединяет и b с a, для ориентированного же это неверно. Чаще всего рассматривают графы, в которых все ребра имеют один тип – либо ориентированные, либо неориентированные. В соответствии с этим и весь граф называют ориентированным или неориентированным
                                </p>

                                <h3>2. Кратные ребра</h3>
                                <p>
                                    Следующий пункт, требующий уточнения – могут ли два разных ребра соединять одну и ту же пару вершин? Если да, то говорят, что в графе допускаются кратные ребра. Граф с кратными ребрами называют также мультиграфом.
                                </p>

                                <h3>3. Петли</h3>
                                <p>
                                Ребро, которому поставлена в соответствие пара вида (a, a) , то есть ребро, соединяющее вершину a с нею же самой, называется петлей. Если такие ребра не допускаются, то говорят, что рассматриваются графы без петель.
                                </p>
                                <p>
                                Комбинируя эти три признака, можно получить разные варианты определения понятия графа. Особенно часто встречаются неориентированные графы без петель и кратных ребер. Такие графы называют обыкновенными, или простыми. Если в графе нет кратных ребер, то есть для каждой пары вершин имеется не более одного соединяющего их ребра, то можно просто отождествить ребра с соответствующими парами вершин – считать, что ребро это и есть пара вершин. Чтобы исключить петли, достаточно оговорить, что вершины, образующие ребро, должны быть различны. Это приводит к следующему определению обыкновенного графа.
                                </p>

                                <p>
                                Обыкновенным графом называется пара G = (V, E) , где V – конечное множество, E – множество неупорядоченных пар различных элементов из V. Элементы множества V называются вершинами графа, элементы множества E – его ребрами.
                                </p>

                                <p>
                                Определения других типов графов без кратных ребер легко получить из этого: если заменить слово «неупорядоченных» на «упорядоченных», получится определение ориентированного графа без петель, если убрать слово «различных», получится определение графа с петлями. Ориентированный граф коротко называют орграфом.
                                </p>

                                <p>
                                Сумма степеней всех вершин графа равна 2m, где m – число ребер, поскольку каждое ребро увеличивает степени ровно двух вершин на единицу. Таким образом, сумма степеней вершин всегда четна. Граф называется
                                регулярным, если степени всех его вершин одинаковы (равны некоторой
                                константе d). Граф называется полным, если степень каждой его вершины
                                равна n − 1, т. е. в графе присутствуют все возможные ребра.
                                </p>
                                <p>
                                В ориентированном графе полустепенью захода вершины называется
                                число ребер, оканчивающихся в этой вершине, а полустепенью исхода –
                                число ребер, начинающихся в вершине. На рис. 7.10 показаны полустепени захода и исхода для каждой вершины графа. Например, для вершины 2
                                полустепень захода равна 2, а полустепень исхода – 1.
                                </p>

                                <img alt='' src={hlst} className="picture" ></img>

                                <p>
                                Граф называется двудольным, если его вершины можно раскрасить в два
                                    цвета, так что цвета любых двух соседних вершин различны. Можно доказать, что граф является двудольным тогда и только тогда, когда в нем нет
                                    цикла с нечетным числом вершин. На рис. 7.11 изображены двудольный
                                    граф и его раскраска
                                </p>

                                <h2 id='2'>Представление графа</h2>

                                <p>
                                Есть несколько способов представить граф в алгоритмах. Выбор структуры данных зависит от размера графа и способа его обработки в алгоритме.
Ниже рассмотрены три популярных представления.
                                </p>

                                <h3>Списки смежности</h3>
                                <p>
                                В этом случае каждой вершине x сопоставляется
список смежности, включающий вершины, соединенные с x ребром. Списки смежности – самый популярный способ представления графов, они позволяют эффективно реализовать большинство алгоритмов.
Списки смежности удобно хранить в массиве векторов, который объявлен следующим образом:

                                </p>

                                <SyntaxHightlighterCPP code={code1}/>

                                <p>
                                Неориентированные графы можно хранить аналогично, только каждое
ребро нужно учитывать в двух списках смежности (для обоих направлений).
Для взвешенных графов структуру следует дополнить:
                                </p>
                                
                                <SyntaxHightlighterCPP code={code2}/>

                                <p>
                                Списки смежности позволяют эффективно находить вершины, в которые можно перейти из данной по одному ребру. Следующий цикл обходит
все вершины, в которые можно попасть из вершины s:
                                </p>

                                <SyntaxHightlighterCPP code={code3}/>

                                <h3>Матрица смежности</h3>
                                
                                <p>
                                    Матрица смежности показывает, какие ребра есть в графе. С ее помощью можно эффективно проверить, существует ли ребро между двумя
вершинами. Матрицу можно хранить в виде массива
                                </p>

                                <SyntaxHightlighterCPP code={code4}/>

                                <p>где элемент adj[a][b] равен 1, если существует ребро, ведущее из вершины a в вершину b, а в противном случае равен 0. Если граф взвешенный, то представление в виде матрицы смежности
можно обобщить: если две вершины соединены ребром, то в матрице хранится вес этого ребра.</p>
                                
Недостаток матрицы смежности заключается в том, что она содержит n^2
элементов, большая часть которых обычно равна 0. Поэтому такое представление не годится для больших графов

                                <h3>Список рёбер</h3>
                                
                                <p>
                                р содержит все ребра графа в некотором порядке. Это представление удобно, если алгоритм обрабатывает все ребра и не требуется
находить ребра, начинающиеся в заданной вершине.
Список ребер можно хранить в векторе

                                </p>
                                <SyntaxHightlighterCPP code={code5}/>
                                <p>Для взвешенных графов структуру можно обобщить:</p>
                                <SyntaxHightlighterCPP code={code6}/>
                                <p>Каждый элемент этого списка имеет вид (a,b,w), это означает, что существует ребро с весом w, ведущее из вершины a в вершину b.</p>

                                
                            </div>
                        </div>

                        <div className="sidebar">
                            <ul>
                                <a href='#1'><li>Определение графа</li></a>
                                <a href='#2'><li>Представление графа</li></a>

                            </ul>
                        </div>
                    </div>
















                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='5'>Описание</h2>

                            
                                <p>
                                    При поиске в ширину (breadth-first search - BFS) вершины графа посещаются в 
                                    порядке возрастания расстояния от начальной вершины. Следовательно, 
                                    используя поиск в ширину, мы сможем вычислить расстояния от
                                    начальной вершины до всех остальных.
                                </p>

                                <p>
                                BFS начинается с добавления исходной вершины s в очередь, затем обрабатывает очередь следующим образом: вынимает самую первую вершину u из
очереди, ставит в очередь все непосещенные соседние вершины u (обычно соседние вершины упорядочены на основе их номеров вершин) и отмечает их
как посещенные. В порядке организованной таким образом очереди BFS будет
посещать вершины s и все вершины в компоненте связности, который содержит s, слой за слоем. Алгоритм BFS также выполняется за O(V + E) и O(V^2) на
графе, представленном как список смежности и матрица смежности соответственно
                                </p>
                                
                                <p>
                                Реализация BFS проста, если мы применяем библиотеки C++ STL или Java
                                API. Мы используем очередь, чтобы упорядочить последовательность посещения вершин, и понять, была ли посещена данная
                                вершина или нет, что в то же время также записывает расстояние (номер слоя)
                                каждой вершины от исходной вершины. 
                                </p>

                                <p>
                                Сам алгоритм можно понимать как процесс "поджигания" графа: на нулевом шаге поджигаем только вершину s. На каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей; т.е. за одну итерацию алгоритма происходит расширение "кольца огня" в ширину на единицу (отсюда и название алгоритма).
                                </p>
                                
                                <h2 id='6'>Релизации</h2>
                                <p>C++:</p>

                                <SyntaxHightlighterCPP code={code11}/> 
                                
                                <p>Python:</p>

                                <SyntaxHightlighterCPP code={code12}/> 
                                
                            </div>
                        </div>
                        <div className="sidebar">
                            <ul>
                                <a href='#5'><li>Описание</li></a>
                                <a href='#6'><li>Реализации</li></a>

                            </ul>
                        </div>
                    </div>















                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='3'>Описание</h2>
                                <p>Поиск в глубину (англ. Depth-first search, DFS) — один из методов обхода графа. Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно. Алгоритм поиска описывается рекурсивно: перебираем все исходящие из рассматриваемой вершины рёбра. Если ребро ведёт в вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой нерассмотренной вершины, а после возвращаемся и продолжаем перебирать рёбра. Возврат происходит в том случае, если в рассматриваемой вершине не осталось рёбер, которые ведут в нерассмотренную вершину. Если после завершения алгоритма не все вершины были рассмотрены, то необходимо запустить алгоритм от одной из нерассмотренных вершин.</p>
                                
                                <p>
                                Поиск в глубину всегда следует по одному пути, пока на нем еще имеются вершины. После этого он возвращается назад и начинает исследовать
другие части графа. Алгоритм запоминает посещенные вершины, так что
каждая обрабатывается только один раз.
                                </p>

                                <img alt='' src={depth_search} className="picture"></img>

                                <h2 id='4'>Реализации</h2>

                                <p>. Поиск в глубину удобно реализовать рекурсивно. Показанная ниже функция dfs начинает поиск с заданной вершины. Предполагается, что граф представлен списками смежности, хранящимися в массиве</p>

                                <SyntaxHightlighterCPP code={code7}/>
                                <p>Кроме того, используется массив</p>
                                <SyntaxHightlighterCPP code={code8}/> 
                                <p>в котором запоминаются посещенные вершины. В начальный момент все
элементы этого массива равны false, но когда алгоритм заходит в вершину s, в элемент visited[s] записывается true. Функцию можно реализовать на C++
следующим образом:</p>
                                <SyntaxHightlighterCPP code={code9}/> 
                                <p>Временная сложность поиска в глубину равна O(n + m), где n – число
вершин, а m – число ребер, поскольку алгоритм обрабатывает каждую вершину и каждое ребро ровно один раз.</p>
                                <p>Реализация на Python:</p>
                                <SyntaxHightlighterCPP code={code10}/> 

                              
                            </div>
                        </div>

                        <div className="sidebar">
                            <ul>
                                <a href='#3'><li>Описание</li></a>
                                <a href='#4'><li>Реализации</li></a>

                            </ul>
                        </div>
                    </div>





















                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                
                                <p>Алгори́тм Де́йкстры (англ. Dijkstra’s algorithm) — алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса. Алгоритм широко применяется в программировании, например, его используют протоколы маршрутизации OSPF и IS-IS.</p>
                                
                                <h2 id='7'>Неформальное объяснение</h2>
                                <p>
                                Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a.
Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки.
Работа алгоритма завершается, когда все вершины посещены.
                                </p>

                                <h3>Инициализация</h3>
                                <p>Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности.
                                Это отражает то, что расстояния от a до других вершин пока неизвестны.
                                Все вершины графа помечаются как непосещённые.</p>

                                <h3>Шаг алгоритма</h3>
                                <p>Если все вершины посещены, алгоритм завершается.
                                В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку.
                                Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом.
                                Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.</p>
                                
                                <img alt='' src={anim} className='picture'></img>
                                            
                                <h2 id='8'>Сложность алгоритма</h2>
                                <p>
                                К этому моменту мы разобрали сам алгоритм, ограничения, накладываемые на его работу и ряд примеров его применения. Давайте упомянем какова вычислительная сложность этого алгоритма, поскольку это пригодится нам для решения задач, ради которых затевалась эта статья.
Базовый подход, основанный на циклах, предполагает проход по всем рёбрам каждого узла, что приводит к сложности O(mn)
                                </p>

                                <p>                        
Эффективная реализация предполагает использование кучи. Об этой структуре данных можно сказать коротко: она позволяет выполнять две операции за логарифмическое время. Первая операция — получение узла в дереве, с наименьшим ключом, и, вторая операция, вставка нового узла в дерево с новым ключом.
                                </p>
                                
                                <p>
                                Используя кучу в алгоритме Дейкстры, где в качестве ключей используются расстояния от вершины в неисследованной части графа (в алгоритме это V-X), до ближайшей вершины в уже покрытом (это множество вершин X), можно сократить вычислительную сложность до O(m\log(n)).
                                </p>
                                
                                <h3 id='9'>Описание работы</h3>
                                <p>
                                Рассмотрим две модели хранения взвешенного графа в памяти. В первой модели (матрица весов, аналог матрицы смежности) будем считать, что вес ребра из вершины i в вершину j равен w[i][j], то есть в матрице w хранятся веса ребра для любых двух вершин. Если из вершины i в вершину j нет ребра, то w[i][j]==INF для некоторого специального значения константы INF. Значение INF следует выбирать исходя из задачи, например, если речь идет о расстояниях между какими-либо населенными пунктами Земли, то можно выбрать значение INF равным 10^9 километров.
                                </p>

                                <p>
                                Алгоритм Дейкстры относится к так называемым «жадным» алгоритмам. Пусть расстояние от начальной вершины start до вершины i хранится в массиве dist[i]. Начальные значения dist[start]=0, dist[i]=INF для всех остальных вершин i. То есть в самом начале алгоритму известен путь из вершины start до вершины start длины 0, а до остальных вершин кратчайшие пути неизвестны. Между тем алгоритм будет постепенно улучшать значения в массиве dist, в результате получит кратчайшие расстояния до всех вершин.
                                </p>

                                <p>
                                В алгоритме Дейкстры вершины красятся в два цвета, будем говорить, что вершина «неокрашенная» или «окрашенная». Изначально все вершины неокрашенные. Если алгоритм Дейкстры покрасил вершину i, то это означает, что найденное значение dist[i] является наилучшим возможным и в последствии не будет улучшаться, то есть значение dist[i] является кратчайшим расстоянием от начальной вершины до вершины i. Если же вершина не покрашена, то величина dist[i] для такой вершины i равна кратчайшему пути из вершины start до вершины i, который проходит только по покрашенным вершинам (за исключением самой вершины i).</p>

                                <p>
                                На каждом шаге алгоритма Дейкстры красится одна новая вершина. В качестве такой вершины выбирается неокрашенная вершина i с наименьшим значением D[i]. Затем рассматриваются все ребра, исходящие из вершины i, и производится релаксация этих ребер, то есть улучшаются расстояния до вершин, смежных с i.
                                </p>
                                <p>
                                Алгоритм заканчивается, когда на очередном шаге не останется неокрашенных вершин или если расстояние до всех неокрашенных вершин будет равно INF (то есть эти вершины являются недостижимыми).
                                </p>
                                <p>Запишем алгоритм Дейкстры. Пусть n — число вершин в графе, вершины пронумерованы от 0 до n - 1. Номер начальной вершины — start и веса ребер хранятся в матрице w.</p>

                                <h3 id='10'>Реализации</h3>
                                <p>C++:</p>
                                <SyntaxHightlighterCPP code={code13}/> 
                                <p>Python:</p>
                                <SyntaxHightlighterCPP code={code14}/> 

                              
                            </div>
                        </div>

                        <div className="sidebar">
                            <ul>
                                <a href='#7'><li>Неформальное объяснение</li></a>
                                <a href='#8'><li>Сложность алгоритма</li></a>
                                <a href='#9'><li>Описание работы</li></a>
                                <a href='#10'><li>Реализации</li></a>
                            </ul>
                        </div>

                        
                    </div>

















                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='11'>Описание</h2>
                                
                                                    <p>Алгоритм Беллмана–Форда находит кратчайшие пути из начальной вершины во все вершины графа. Алгоритм применим к любым графам, не
                    содержащим цикла с отрицательной длиной. Если граф содержит такой
                    цикл, то алгоритм обнаружит это.</p>
                                
                                                            <p>Алгоритм запоминает расстояния от начальной вершины до всех вершин графа. В начальный момент расстояние до начальной вершины равно
                            0, а до всех остальных бесконечно. Затем алгоритм уменьшает расстояния,
                            отыскивая ребра, которые укорачивают пути, и останавливается, когда ни
                            одно расстояние нельзя уменьшить.
                            </p>

                            <p>На рисунке показано, как алгоритм Беллмана–Форда обрабатывает
                            граф. Сначала алгоритм уменьшает расстояния, используя ребра 1 → 2,
                            1 → 3 и 1 → 4, затем – используя ребра 2 → 5 и 3 → 4, и, наконец, используя ребро 4 → 5. После этого не осталось ребер, с помощью которых
                            можно уменьшить расстояния, и, значит, найденные расстояния окончательны.</p>

                            <p>
                            Временная сложность алгоритма Форда–Беллмана составляет O(V3
                            ), если
                            граф хранится в  виде матрицы смежности, или O(VE), если граф хранится
                            в виде списка смежности. Это объясняется тем, что если мы используем матрицу смежности, нам необходимо время O(V2
                            ), чтобы перебрать все ребра в нашем графе. В обоих случаях эта реализация будет работать намного медленнее, чем реализация алгоритма Дейкстры. Однако алгоритм Форда–Беллмана
                            гарантирует отсутствие бесконечных циклов, даже если в данном графе есть
                            цикл отрицательного веса.
                            </p>

                            <img alt='' src={bellman} className='picture'></img>

                                <h2 id='12'>Релизация</h2>

                                    <p>Приведенная ниже реализация алгоритма Беллмана–Форда определяет кратчайшие расстояния от вершины x до всех вершин графа. Предполагается, что граф представлен списком ребер, содержащим
кортежи вида (a,b,w); каждый такой кортеж означает, что существует ребро веса w, соединяющее вершины a и b.</p>

                                        <p>
                                        Алгоритм состоит из n − 1 раундов. На каждом раунде алгоритм перебирает все ребра графа и пытается уменьшить расстояния. Строится массив
distance, в котором хранятся расстояния от вершины x до каждой вершины графа. Константа INF обозначает бесконечное расстояние.

                                        </p>

                                <SyntaxHightlighterCPP code={code15}/>
                                        <p>Временная сложность этого алгоритма равна O(nm), поскольку на каждом из n − 1 раундов перебираются все m ребер. Если в графе нет отрицательных циклов, то после n − 1 раундов расстояния уже не могут измениться, потому что любой кратчайший путь содержит не более n − 1 ребер.</p>
                                    
                                    <p>На практике алгоритм можно оптимизировать несколькими способами.
                                    Во-первых, окончательные расстояния обычно становятся известны еще
                                    до выполнения всех n − 1 раундов, так что можно просто остановить алгоритм, если в очередном раунде ни одно расстояние не удалось уменьшить.
                                    Существует также усовершенствованный алгоритм SPFA (Shortest Path
                                    Faster Algorithm – ускоренный алгоритм поиска кратчайшего пути [10]),
                                    который поддерживает очередь вершин, потенциально способных уменьшить расстояния. Обрабатывать нужно лишь вершины из этой очереди,
                                    что часто повышает эффективность поиска.</p>

                                
                            </div>
                        </div>

                        <div className="sidebar">
                            <ul>
                                <a href='#11'><li>Описание</li></a>
                                <a href='#12'><li>Реализации</li></a>

                            </ul>
                        </div>
                    </div>















                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='13'>Описание</h2>
                                <p>Алгоритм Флойда–Уоршелла предлагает другой подход к задаче поиска
кратчайших путей. В отличие от других алгоритмов, он находит кратчайшие пути между всеми парами вершин за один проход. </p>
<p>Алгоритм манипулирует матрицей, содержащей расстояния между парами вершин. В начальный момент матрица инициализируется на основе матрицы смежности. Затем алгоритм выполняет несколько раундов,
на каждом из которых выбирает новую вершину, которая в дальнейшем
может быть промежуточной вершиной в путях, и уменьшает расстояния,
используя эту вершину.</p>
                                 <p>Продемонстрируем работу алгоритма Флойда–Уоршелла на примере
графа на рисунке. В этом случае начальная матрица выглядит так:
</p>
                            <img alt='' src={fl1} className='picture'></img>

                            <img alt='' src={fl2} className='picture'></img>
                                        <p>В первом раунде новой промежуточной вершиной становится вершина 1. Между вершинами 2 и 4 обнаруживается новый путь длины 14, поскольку их соединяет вершина 1. Обнаруживается также новый путь длины 6 между вершинами 2 и 5.</p>
                            <img alt='' src={fl3} className='picture'></img>
<p>Во втором раунде новой промежуточной вершиной становится вершина 2. В результате создаются новые пути между вершинами 1 и 3 и вершинами 3 и 5.</p>

                            <img alt='' src={fl4} className='picture'></img>
<p>Алгоритм продолжает работу до тех пор, пока все вершины не окажутся
промежуточными. И в этот момент матрица будет содержать минимальные расстояния между всеми парами вершин:
</p>

                            <img alt='' src={fl5} className='picture'></img>
<p>Например, мы видим, что кратчайшее расстояние между вершинами 2 и
4 равно 8. Ему соответствует путь, показанный на рисунке.</p>
                            <img alt='' src={fl6} className='picture'></img>

                                <h2 id='14'>Релизация</h2>

                                    <p>Реализовать алгоритм Флойда–Уоршелла очень просто.
Приведенная ниже реализация строит матрицу расстояний, в которой элемент dist[a][b] равен кратчайшему расстоянию между вершинами a и b.
Вначале алгоритм инициализирует dist на основе матрицы смежности
графа adj:
</p>

                                <SyntaxHightlighterCPP code={code16}/>

                                <p>Временная сложность алгоритма равна O(n
3
), так как он содержит три
вложенных цикла, в которых перебираются вершины графа.
Поскольку реализация алгоритма Флойда–Уоршелла так проста, его
можно порекомендовать даже тогда, когда требуется найти лишь один
кратчайший путь в графе. Однако его можно использовать только для небольших графов, когда кубическая временная сложность приемлема.</p>
                                        
                                
                            </div>
                        </div>

                        <div className="sidebar">
                            <ul>
                                <a href='#13'><li>Описание</li></a>
                                <a href='#14'><li>Реализации</li></a>

                            </ul>
                        </div>
                    </div>
















                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='15'>Описание</h2>
                                    <p>Алгоритм Краскала строит минимальное остовное дерево, жадно добавляя в граф ребра. Начальное остовное дерево содержит только вершины
                                    графа и ни одного ребра. Затем алгоритм перебирает ребра, отсортированные в порядке возрастания весов, и всякий раз добавляет ребро в граф,
                                    если при этом не образуется цикл</p>
                                    <p>Алгоритм манипулирует компонентами связности графа. Вначале каждая вершина графа принадлежит отдельной компоненте. При добавлении
                                    в граф нового ребра две компоненты объединяются. В конце все вершины будут принадлежать одной компоненте, она и является минимальным
                                    остовным деревом.</p>

                                    <p>
                                    Пусть входе имеется пустой подграф, который и будем достраивать до потенциального минимального остовного дерева. Будем рассматривать только связные графы, в другом случае при применении алгоритма Краскала мы будем получать не минимальное остовное дерево, а просто остовной лес.
                                    </p>

                                    <ul>
                                        <li>Вначале мы производим сортировку рёбер по неубыванию по их весам.</li>
                                        <li>Добавляем i-ое ребро в наш подграф только в том случае, если данное ребро соединяет две разные компоненты связности, одним из которых является наш подграф. То есть, на каждом шаге добавляется минимальное по весу ребро, один конец которого содержится в нашем подграфе, а другой - еще нет.</li>
                                        <li>Алгоритм завершит свою работу после того, как множество вершин нашего подграфа совпадет с множеством вершин исходного графа.</li>
                                    </ul>
                                    <p>Данный алгоритм называется жадным из-за того, что мы на каждом шаге пытаемся найти оптимальный вариант, который приведет к оптимальному решению в целом.</p>

                                    <p>Рассмотрим граф:</p>
                            <img alt='' src={kr1} className='picture'></img>
                                    <p>Выпишем все его ребра в отсортированном порядке:</p>
                                    <SyntaxHightlighterCPP code={code17}/>

                                    <p>И начнем по списку добавлять эти ребра в наш остов:</p>
                                    <img alt='' src={kr2} className='picture'></img>
                                    <img alt='' src={kr3} className='picture'></img>
                                    <p>При добавлении в наше остовное дерево ребра A {"<-->"} C, как вы можете заметить, образовывается цикл, поэтому мы просто пропускаем данное ребро.</p>

                                    <p>По итогу у нас образовывается следующий подграф, и как вы заметили, мы соединили все вершины ребрами с минимально-возможными весами, а значит, нашли минимальное остовное дерево для нашего исходного графа.</p>

                                    <img alt='' src={kr4} className='picture'></img>

                                    <p>Проводим проверку с помощью встроенного алгоритма для нахождения MST на graphonline, и видим, что подграфы идентичны.
И да, из-за того, что при равенстве весов рёбер мы можем выбрать любое из них, конечные подграфы, являющиеся минимальными остовными деревьями, могут различаться с точностью до некоторых рёбер.</p>

<img alt='' src={kr5} className='picture'></img>

<p>Суммарный вес искомого MST равен 33.</p>

                                <h2 id='16'>Релизация</h2>
                                    <p>Реализовать представленный алгоритм проще всего с помощью СНМ(система непересекающихся отрезков).</p>

                                    <p>Вначале, как мы уже раннее говорили, необходимо отсортировать ребра по неубыванию по их весам. Далее с помощью вызовов функции make_set()мы каждую вершину можем поместить в свое собственное дерево, то есть, создаем некоторое множество подграфов. Дальше итерируемся по всем ребрам в отсортированном порядке и смотрим, принадлежат ли инцидентные вершины текущего ребра разным подграфам с помощью функции find_set() или нет, если оба конца лежат в разных компонентах, то объединяем два разных подграфа в один с помощью функции union_sets().</p>

                                <SyntaxHightlighterCPP code={code18}/>


                                        
                            
                            </div>
                        </div>

                        <div className="sidebar">
                            <ul>
                                <a href='#15'><li>Описание</li></a>
                                <a href='#16'><li>Реализация</li></a>

                            </ul>
                        </div>
                    </div>
























                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='19'>Описание</h2>

                                <p>Алгоритм Прима дает другой способ построения минимального остовного дерева. Сначала он добавляет в дерево произвольную вершину, а при
добавлении каждой следующей вершины выбирает ребро с минимальным
весом. После того как все вершины добавлены, минимальное остовное дерево построено.</p>

<p>Алгоритм Прима напоминает алгоритм Дейкстры. Разница в том, что
алгоритм Дейкстры всегда выбирает вершину с минимальным расстоянием от начальной вершины, а алгоритм Прима выбирает для добавления в
дерево вершину, принадлежащую ребру с минимальным весом</p>

<p>На рисунке показано, как алгоритм Прима строит минимальное остовное дерево для рассмотренного выше графа, начиная с вершины 1. Как
и алгоритм Дейкстры, алгоритм Прима можно эффективно реализовать с
помощью очереди с приоритетом. Очередь должна содержать все вершины, которые можно соединить с уже построенной частью дерева одним
ребром, причем эти вершины должны храниться в порядке возрастания
весов соответствующих ребер.</p>

                            <img alt='' src={prime} className='picture'></img>

                                    <p>Временная сложность алгоритма Прима равна O(n + m log m), т. е. такая
же, как у алгоритма Дейкстры. На практике алгоритмы Прима и Краскала
одинаково эффективны, так что выбор между ними – дело вкуса. Тем не
менее на олимпиадах чаще выбирают алгоритм Краскала.</p>
                                             
                                
                            </div>
                        </div>

                        <div className="sidebar">
                            <ul>
                                <a href='#19'><li>Описание</li></a>
                               

                            </ul>
                        </div>
                    </div>

























                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='20'>Описание</h2>
                                <p>Во многих приложениях мы используем направленные ациклические графы для указания прецедентов среди событий. Например, в задаче планирования существует набор задач и набор ограничений, определяющих порядок выполнения этих задач. Мы можем построить DAG для представления задач. Направленные ребра DAG (ориентированный ациклический граф) представляют порядок задач.</p>

                                <p>Давайте рассмотрим проблему с тем, как человек может одеться для официального случая. Нам нужно надеть несколько предметов одежды, таких как носки, брюки, обувь и т. Д. Некоторые предметы одежды должны быть надеты раньше других. Например, нам нужно надеть носки перед обувью. Некоторые предметы одежды можно надевать в любом порядке, например, носки и брюки. Мы можем использовать DAG для иллюстрации этой проблемы:</p>

                                <img alt='' src={tp1} className='picture'></img>

                                <p>В этом DAG вершины соответствуют предметам одежды. Прямое ребро (u, v)в DAG указывает, что нам нужно надеть одежду uперед одеждой v. Наша задача - найти порядок, позволяющий надевать все предметы одежды, соблюдая ограничения зависимостей. Например, мы можем надеть одежду в следующем порядке:</p>

                                <img alt='' src={tp2} className='picture'></img>

                                <p>Топологическая сортировка DAG G - это линейный порядок всех его вершин, такой, что если Gсодержит ребро (u, v), то uпоявляется раньше vв упорядочении.Для DAG мы можем построить топологическую сортировку с временем выполнения, линейным числу вершин плюс числу ребер, что равно O(V + E).</p>


                                <h2>Алгоритм Кана</h2>

                                <p>В алгоритме Кана мы строим топологическую сортировку в DAG путем нахождения вершин, у которых нет входящих ребер.</p>
                                <p>Мы сначала вычисляем значения степени для всех вершин. Затем мы начинаем с вершины, степень которой равна 0, и помещаем ее в конец выходного списка. Как только мы выбираем вершину, мы обновляем значения степени ее смежных вершин, потому что вершина и ее внешние ребра удаляются из графика.</p>

                                <p>Мы можем повторять описанный выше процесс, пока не выберем все вершины. Тогда выходной список представляет собой топологический вид графа.</p>

                                <p>Чтобы вычислить степени всех вершин, нам нужно посетить все вершины и ребра G. Следовательно, время выполнения предназначено O(V + E)для вычислений в степени. Чтобы избежать повторного вычисления этих значений, мы можем использовать массив для отслеживания значений степени этих вершин. Внутри цикла while нам также нужно посетить все вершины и ребра. Следовательно, общее время выполнения равно O(V + E).</p>

                                <h2 id='21'>Релизация</h2>
                                <p>C++:</p>

                                <SyntaxHightlighterCPP code={code20}/> 

                            </div>
                        </div>
                        <div className="sidebar">
                            <ul>
                                <a href='#20'><li>Описание</li></a>
                                <a href='#21'><li>Реализация</li></a>

                            </ul>
                        </div>
                    </div>





















                    <div className="flex__cont__for__articles">
                        <div className="article" id="a0">
                            <div className="text">
                                <h2 id='20'>Описание</h2>

                                    <p>Остаточной пропускной способностью называется пропускная способность ребра за вычетом текущего потока вдоль этого ребра. При этом надо помнить, что если некоторый поток протекает по ориентированному ребру, то возникает так называемое обратное ребро (направленное в обратную сторону), которое будет иметь нулевую пропускную способность, и по которому будет протекать тот же по величине поток, но со знаком минус. Если же ребро было неориентированным, то оно как бы распадается на два ориентированных ребра с одинаковой пропускной способностью, и каждое из этих рёбер является обратным для другого (если по одному протекает поток F, то по другому протекает -F).</p>

                                    <p>Общая схема алгоритма Эдмондса-Карпа такова. Сначала полагаем поток равным нулю. Затем ищем дополняющий путь, т.е. простой путь из S в T по тем рёбрам, у которых остаточная пропускная способность строго положительна. Если дополняющий путь был найден, то производится увеличение текущего потока вдоль этого пути. Если же пути не было найдено, то текущий поток является максимальным. Для поиска дополняющего пути может использоваться как Обход в ширину, так и Обход в глубину.</p>

                                    <p>Рассмотрим более точно процедуру увеличения потока. Пусть мы нашли некоторый дополняющий путь, тогда пусть C - наименьшая из остаточных пропускных способностей рёбер этого пути. Процедура увеличения потока заключается в следующем: для каждого ребра (u, v) дополняющего пути выполним: Fu, v += C, а Fv, u = - Fu, v (или, что то же самое, Fv, u -= C).</p>

                                    <p>Величиной потока будет сумма всех неотрицательных величин FS, v, где v - любая вершина, соединённая с истоком.</p>
                                <h2 id='21'>Релизация</h2>
                                <p>C++:</p>

                                <SyntaxHightlighterCPP code={code19}/> 

                            </div>
                        </div>
                        <div className="sidebar">
                            <ul>
                                <a href='#20'><li>Описание</li></a>
                                <a href='#21'><li>Реализация</li></a>

                            </ul>
                        </div>
                    </div>








                </MyTabs>
            </div>
        </div>
    )
}

export default Graphs