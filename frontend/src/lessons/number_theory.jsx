import Topbar from "../baza/Topbar";
import '../css/style.css'
import React from 'react';
import MyTabs from "../baza/MyTabs";
import Question from "../baza/question";
import resheto1 from '../pics/resheto1.png'
import resheto2 from '../pics/resheto2.png'
import resheto3 from '../pics/resheto3.gif'
import eucll from '../pics/eucl.png'
import eucl2 from '../pics/eucl2.png'
import eucl3 from '../pics/eucl3.png'
import step1 from '../pics/step1.png'
import eee1 from '../pics/eee1.png'
import eee2 from '../pics/eee2.png'
import eee3 from '../pics/eee3.png'
import eee4 from '../pics/eee4.png'
import eee5 from '../pics/eee5.png'
import eee6 from '../pics/eee6.png'
import eee7 from '../pics/eee7.png'
import eee8 from '../pics/eee8.png'
import dio1 from '../pics/dio1.png'
import dio2 from '../pics/dio2.png'
import dio3 from '../pics/dio3.png'
import dio4 from '../pics/dio4.png'
import dio5 from '../pics/dio5.png'
import dio6 from '../pics/dio6.png'
import dio7 from '../pics/dio7.png'
import dio8 from '../pics/dio8.png'
import dio9 from '../pics/dio9.png'
import igr1 from '../pics/igr1.png'
import igr2 from '../pics/igr2.png'
import igr3 from '../pics/igr3.png'
import igr4 from '../pics/igr4.png'
import igr5 from '../pics/igr5.png'
import fr1 from '../pics/fr1.png'
import fr2 from '../pics/fr2.png'
import fr3 from '../pics/fr3.png'
import fr4 from '../pics/fr4.png'
import fr5 from '../pics/fr5.png'
import fr6 from '../pics/fr6.png'
import fr7 from '../pics/fr7.png'
import fr8 from '../pics/fr8.png'
import fr9 from '../pics/fr9.png'
import fr10 from '../pics/fr10.png'
import fr11 from '../pics/fr11.png'
import fr12 from '../pics/fr12.png'
import fr13 from '../pics/fr13.png'
import fr14 from '../pics/fr14.png'

import SyntaxHightlighterCPP from "../baza/CodeBlocksCPP";
import Article from "../baza/CreateArticle";

const code2 = `for (int x = 2; x <= n; x++) {
    if (sieve[x]) continue;
    for (int u = 2*x; u <= n; u += x) {
        sieve[u] = 1;
    }
}
   `
const code3 = `int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a%b);
}
   `
const code4 = `ax + by = gcd(a, b).`
const code5 = `30 · 1 + 12 · (−2) = 6.`
const code6 = `bx' + (a mod b)y' = gcd(a, b).`
const code7 = `bx' + (a − ⌊a/b⌋ · b)y' = gcd(a, b),`
const code8 = `ay' + b(x' − ⌊a/b⌋ · y') = gcd(a, b).`
const code9 = `tuple<int,int,int> gcd(int a, int b) {
    if (b == 0) {
        return {1,0,a};
    } else {
        int x,y,g;
        tie(x,y,g) = gcd(b,a%b);
        return {y,x-(a/b)*y,g};
    }
}
   `
const code10 = `int x,y,g;
tie(x,y,g) = gcd(30,12);
cout << x << " " << y << " " << g << " "; 
// 1 -2 6`
const code11 = `int modpow(int x, int n, int m) {
    if (n == 0) return 1%m;
    long long u = modpow(x,n/2,m);
    u = (u*u)%m;
    if (n%2 == 1) u = (u*x)%m;
    return u;
}`
const code12 = `ax + by = c,`
const code13 = `5x + 2y = 11`
const code14 = `ax + by = gcd(a, b).`
const code15 = `39x + 15y = 12.`
const code16 = `39 · 2 + 15 · (−5) = 3,`
const code17 = `39 · 8 + 15 · (−20) = 12,`
const code18 = `typedef complex<double> cd;
double pi = acos(-1);
`
const code19 = `
vector<cd> fft(vector<cd> a, int d = 1) {
    int n = a.size();
    vector<cd> r(n);
    for (int k = 0; k < n; k++) {
        int b = 0;
        for (int z = 1; z < n; z *= 2) {
            b *= 2;
            if (k&z) b++;
        }
        r[b] = a[k];
    }
    for (int m = 2; m <= n; m *= 2) {
        cd wm = exp(cd{0,d*2*pi/m});
        for (int k = 0; k < n; k += m) {
            cd w = 1;
            for (int j = 0; j < m/2; j++) {
                cd u = r[k+j];
                cd t = w*r[k+j+m/2];
                r[k+j] = u+t;
                r[k+j+m/2] = u-t;
                w = w*wm;
            }
        }
    }
    if (d == –1) {
        for (int i = 0; i < n; i++) r[i] /= n;
    }
    return r;
}
   `
const code20 = `int n = 4;
vector<cd> f = {3,2,0,0};
vector<cd> g = {1,5,0,0};
auto tf = fft(f);
auto tg = fft(g);
vector<cd> tp(n);
for (int i = 0; i < n; i++) tp[i] = tf[i]*tg[i];
auto p = fft(tp,-1); // [3,17,10,0]`
const code21 = ``
const code22 = ``
const code23 = ``
const code24 = ``
const code25 = ``
const code26 = ``
const code27 = ``
const code28 = ``

const Number_theory = () => {
    return (
        <div>
            <Topbar></Topbar>

            <div style={{ maxWidth: 950, textAlign: 'left', margin: '0 auto'}}>
                <h1 style={{ maxWidth: 950, marginBottom: 0, marginTop: 40}}>Темы:</h1>
            </div>

            <div className="main__cont">
                
                <MyTabs themes={['Решето Эратосфена', 'Алгоритм Евклида', 'Возведение в степень по модулю', 'Диофантовы уравнения', 'Игра ним', 'Преобразование Фурье и работа с полиномами', 'Алгоритм БПФ', 'Вычисление свёртки']}>


                    <Article data={[['История', 'h1'],
                    ['Этот метод описан во «Введении в арифметику» Никомаха Герасского. Никомах называет автором метода Эратосфена. То же делает и Ямвлих в своём комментарии к этому сочинению Никомаха.', 'p'],
                    ['Название «решето» метод получил потому, что во времена Эратосфена писали числа на дощечке, покрытой воском, и прокалывали дырочки в тех местах, где были написаны составные числа. Поэтому дощечка являлась неким подобием решета, через которое «просеивались» все составные числа, а оставались только числа простые.', 'p'],
                    ['Описание', 'h1'],
                    [`Решето Эратосфена – это алгоритм предварительной обработки, который строит массив sieve, позволяющий для каждого целого числа от 2
                    до n эффективно определить, является ли оно простым. Если x простое, то
                    sieve[x] = 0, иначе sieve[x] = 1. На рисунке показано содержимое массива
                    sieve для n = 20.`, 'p'],
                    [resheto1, 'img'],
                    [`Для построения массива алгоритм перебирает числа 2 · n. Обнаружив
                    новое простое число x, алгоритм помечает, что числа 2x, 3x, 4x и т. д. не
                    простые. Ниже показана возможная реализация алгоритма в предположении, что вначале все элементы sieve равны нулю:`, 'p'],
                    [code2, 'code'],
                    [`Внутренний цикл алгоритма выполняется ⌊n/x⌋ раз для каждого значения x. Следовательно, время работы может быть оценено сверху частичной суммой гармонического ряда:`, 'p'],
                    [resheto2, 'img'],
                    [`На самом деле алгоритм более эффективен, поскольку внутренний цикл
                    выполняется, только если число x простое. Можно показать, что временная
                    сложность алгоритма равна всего лишь O(n log log n), что весьма близко к
                    O(n). На практике решето Эратосфена очень эффективно.`, 'p'],
                    [resheto3, 'img'],

                    ]}/>

              

















                    <Article data = {[
                        ['История', 'h1'],
                        [`Древнегреческие математики называли этот алгоритм ἀνθυφαίρεσις или ἀνταναίρεσις — «взаимное вычитание». Этот алгоритм не был открыт Евклидом, так как упоминание о нём имеется уже в Топике Аристотеля (IV век до н. э.). В «Началах» Евклида он описан дважды — в VII книге для нахождения наибольшего общего делителя двух натуральных чисел и в X книге для нахождения наибольшей общей меры двух однородных величин. В обоих случаях дано геометрическое описание алгоритма, для нахождения «общей меры» двух отрезков.`, 'p'],
                        ['Историками математики было выдвинуто предположение, что именно с помощью алгоритма Евклида (процедуры последовательного взаимного вычитания) в древнегреческой математике впервые было открыто существование несоизмеримых величин (стороны и диагонали квадрата, или стороны и диагонали правильного пятиугольника). Впрочем, это предположение не имеет достаточных документальных подтверждений. Алгоритм для поиска наибольшего общего делителя двух натуральных чисел описан также в I книге древнекитайского трактата Математика в девяти книгах.', 'p'],
                        ['Описание', 'h1'],
                        [`Наибольшим общим делителем (НОД) целых чисел a и b, gcd(a, b), называется наибольшее целое число, которое делит одновременно a и b. Например, gcd(30, 12) = 6. С наибольшим общим делителем тесно связано
                        понятие наименьшего общего кратного (НОК) – наименьшего целого числа, которое делится одновременно на a и на b; оно обозначается lcm(a, b).
                        Формулу`, 'p'],
                        [eucll, 'img'],
                        ['можно использовать для вычисления наименьшего общего кратного. Например, lcm(30, 12) = 360/gcd(30, 12) = 60.', 'p'],
                        [`Один из способов нахождения gcd(a, b) – разложить a и b на простые
                        множители, а затем для каждого простого числа взять наибольшую
                        степень, в которой оно входит в оба разложения. Так, чтобы вычислить
                        gcd(30, 12), мы можем построить разложения 30 = 2 · 3 · 5 и 12 = 22
                        · 3, а
                        затем сделать вывод, что gcd(30, 12) = 2 · 3 = 6. Однако для больших a и b
                        этот метод неэффективен.`, 'p'],
                        [`Алгоритм Евклида дает эффективный способ вычисления gcd(a, b). Он
                        основан на формуле`, 'p'],
                        [eucl2, 'img'],
                        ['Например:', 'p'],
                        [eucl3, 'img'],
                        ['Этот алгоритм можно реализовать следующим образом:', 'p'],
                        [code3, 'code'],
                        ['Расширенный алгоритм Евклида', 'h2'],
                        ['Алгоритм Евклида можно модифицировать так, чтобы он давал числа x и y – такие, что', 'p'],
                        [code4, 'code'],
                        ['Например, при a = 30 и b = 12 имеем', 'p'],
                        [code5, 'code'],
                        [`Эту задачу также можно решить, воспользовавшись тождеством
                        gcd(a,  b) =  gcd(b,  a  mod  b). Предположим, что задача уже решена для
                        gcd(b, a mod b), и мы знаем x' и y' – такие, что`, 'p'],
                        [code6, 'code'],
                        [`Тогда поскольку a mod b = a − ⌊a/b⌋ · b, то`, 'p'],
                        [code7, 'code'],
                        ['или', 'p'],
                        [code8, 'code'],
                        [`Таким образом, мы можем взять x = y' и y = x' −⌊a/b⌋ · y'. На этой идее основана показанная ниже функция, которая возвращает кортеж (x, y, gcd(a, b)),
                        удовлетворяющий уравнению.`, 'p'],
                        [code9, 'code'],
                        [`Эту функцию можно использовать следующим образом:`, 'p'],
                        [code10, 'code'],
                    ]}/>







                







                    <Article data = {[
                        ['Описание', 'h1'],
                        [`Часто бывает нужно эффективно вычислить значение x
                        n mod m. Это
                        можно сделать за время O(log n), воспользовавшись следующим рекуррентным соотношением:
                        `, 'p'],
                        [step1, 'img'],
                        [`Например, для вычисления x
                        ^100 мы сначала вычисляем x^50, а затем пользуемся формулой x^100 = x^50 · x^50. Далее для вычисления x^50 мы сначала вычисляем x^25 и т. д. Поскольку при четном n показатель степень уменьшается
                        вдвое, это вычисление занимает время O(log n).
                        Алгоритм реализуется следующей функцией:`, 'p'],
                        [code11, 'code'],
                        ['Теорема Эйлера', 'h1'],
                        [`Два целых числа a и b называются взаимно простыми, если gcd(a, b) = 1.
                        Функция Эйлера φ(n) определяет количество целых чисел от 1 до n, взаимно простых с n. Например, φ(10) = 4, потому что числа 1, 3, 7 и 9 взаимно
                        просты с 10.`, 'p'],
                        [`Для любого n значение φ(n) можно вычислить, зная разложение n на
                        простые множители, по формуле
                        `, 'p'],
                        [eee1, 'img'],
                        [`Например, поскольку 10 = 2 · 5, то φ(10) = 20 · (2 − 1) · 50 · (5 − 1) = 4.
                        Теорема Эйлера утверждает, что
                        `, 'p'],
                        [eee2, 'img'],
                        [`для всех положительных взаимно простых чисел x и m. Так, согласно теореме Эйлера 74
                        mod 10 = 1, поскольку 7 и 10 – взаимно простые числа и
                       φ(10) = 4.
                       Если m простое, то φ(m) = m − 1, и эта формула принимает вид`, 'p'],
                        [eee3, 'img'],
                        [`В таком виде она известна как малая теорема Ферма. Из нее следует, что`, 'p'],
                        [eee4, 'img'],
                        [`и этот факт можно использовать для вычисления x
                        n при очень больших n.
                        Вычисление обратной величины по модулю. Обратной величиной x
                        относительно умножения по модулю m называется такое число invm
                        (x),
                        что
                        `, 'p'],
                        [eee5, 'img'],
                        [`Например, inv17(6) = 3, т. к. 6 · 3 mod 17 = 1.
                        `, 'p'],
                        [`Обращение по модулю позволяет делить числа по модулю m, поскольку деление x эквивалентно умножению на invm
                        (x). Например, зная, что
                        inv17(6) = 3, мы можем вычислить, чему равно 36/6 mod 17, найдя значение
                        36 · 3 mod 17.`, 'p'],
                        [`Обращение по модулю возможно тогда и только тогда, когда x и m взаимно просты. В этом случае справедлива формула
                        `, 'p'],
                        [eee6, 'img'],
                        [`основанная на теореме Эйлера. В частности, если число m простое, то
                        φ(m) = m – 1, и эта формула принимает вид
                        `, 'p'],
                        [eee7, 'img'],
                        [`Например:`, 'p'],
                        [eee8, 'img'],
                        [`Данная формула позволяет эффективно вычислять обратные величины
                        по модулю, применяя алгоритм возведения в степень по модулю.`, 'p'],

                    ]}/>




                    








                    <Article data = {[
                        [`Решение уравнений в целых числах`, 'h1'],
                        [`Диофантовым уравнением называется уравнение вида`, 'p'],
                        [code12, 'code'],
                        [`где a, b и c – постоянные, а найти требуется x и y. Все числа в этом уравнении должны быть целыми. Например, одним из решений уравнения`, 'p'],
                        [code13, 'code'],
                        [`является x = 3, y = −2.`, 'p'],
                        [`Для эффективного решения диофантова уравнения можно воспользоваться расширенным алгоритмом Евклида (раздел 11.1.3), который находит целые числа x и y – такие, что удовлетворяется уравнение`, 'p'],
                        [`Диофантово уравнение разрешимо тогда и только тогда, когда c делится
                        на gcd(a, b).`, 'p'],
                        [`Например, найдем целые x и y, удовлетворяющие уравнению`, 'p'],
                        [code14, 'code'],
                        [`Это уравнение разрешимо, потому что gcd(39, 15) = 3 и 3 | 12. Расширенный алгоритм Евклида дает`, 'p'],
                        [code15, 'code'],
                        [`а после умножения на 4 это равенство принимает вид`, 'p'],
                        [`так что решением уравнения является x = 8, y = −20.`, 'p'],
                        [`Решение диофантова уравнения не единственно, потому что, зная одно
                        решение, можно получить еще бесконечно много. Если пара (x, y) является
                        решением, то решениями будут и все пары вида`, 'p'],
                        [dio1, 'img'],
                        [`где k – любое целое число.`, 'p'],
                        [`Китайская теорема об остатках`, 'h1'],
                        [`Эта теорема касается решения системы уравнений вида`, 'p'],
                        [dio2, 'img'],
                        [`где числа m1
                        , m2
                        , …, mn
                        попарно взаимно простые. Можно доказать, что решением этой системы уравнений является`, 'p'],
                        [dio3, 'img'],
                        [`где`, 'p'],
                        [dio4, 'img'],
                        [`В этом решении для каждого k = 1, 2, …, n`, 'p'],
                        [dio5, 'img'],
                        [`потому что`, 'p'],
                        [dio6, 'img'],
                        [`Поскольку все остальные члены суммы делятся на mk
                        , они не влияют на
                        остаток и x mod mk
                        = ak
                        .`, 'p'],
                        [`Например, решением системы`, 'p'],
                        [dio7, 'img'],
                        [`является число`, 'p'],
                        [dio8, 'img'],
                        [`Найдя одно решение x, мы можем получить еще бесконечно много решений вида`, 'p'],
                        [dio9, 'img'],
                    ]}/>














                     <Article data = {[
                        [`Состояния игры`, 'h1'],
                        [`Рассмотрим игру, в начале которой имеется кучка из n палочек. Два
                        игрока ходят по очереди, и на каждом ходе игрок может взять из кучки
                        1, 2 или 3 палочки. Игрок, который забирает последнюю палочку, выигрывает.`, 'p'],
                        [`Например, при n = 10 игра может протекать следующим образом:`, 'p'],
                        [[
                        `игрок A берет 2 палочки (остается 8 палочек);`,
                        `игрок B берет 3 палочки (остается 5 палочек);`,
                        `игрок A берет 1 палочку (остается 4 палочки);`,
                        `игрок B берет 2 палочки (остается 2 палочки);`,
                        `игрок A берет 2 палочки и выигрывает.`,
                        ], 'ul'],
                        [`Состояния игры 0, 1, 2, …, n соответствуют количеству оставшихся палочек.`, 'p'],
                        [`Выигрышным называется состояние, в котором игрок выигрывает, если
                        применяет оптимальную стратегию, а проигрышным – состояние, в котором игрок проигрывает, если противник применяет оптимальную стратегию. Оказывается, что любое состояние игры является либо выигрышным,
                        либо проигрышным.`, 'p'],
                        [`В рассмотренной выше игре состояние 0, очевидно, проигрышное, потому что игрок не может сделать ни одного хода. Состояния 1, 2, 3 выигрышные, потому что игрок может забрать 1, 2 или 3 палочки и выиграть.
                        Состояние 4, напротив, проигрышное, потому что любой ход приводит к
                        состоянию, в котором выигрывает противник.`, 'p'],
                        [`Вообще, если существует ход, который ведет из текущего состояния в
                        проигрышное, то это выигрышное состояние, в противном случае – проигрышное. Пользуясь этим наблюдением, мы можем классифицировать все
                        состояния игры, начав с проигрышных состояний, в которых нет ни одного возможного хода. На рис. 11.20 показана классификация состояний
                        0…15 (W обозначает выигрышное состояние, L – проигрышное).`, 'p'],
                        [igr1, 'img'],
                        [`Эту игру легко проанализировать: состояние k проигрышное, если k делится на 4, и выигрышное в противном случае. Оптимальная стратегия –
                        всегда брать столько палочек, чтобы количество оставшихся в кучке делилось на 4. В конечном итоге палочек не останется, и противник проиграет.
                        Разумеется, для применения этой стратегии
                        необходимо, чтобы при своем ходе количество
                        палочек не было кратно 4, иначе мы ничего не
                        сможем сделать, и противник выиграет, если будет играть оптимально.`, 'p'],
                        [igr2, 'img'],
                        [`Рассмотрим другую игру с палочками: в каждом состоянии k разрешено брать из кучки любое число палочек x, которое меньше k и делит k.
                        Например, в состоянии 8 можно взять 1, 2 или 4
                        палочки, а в состоянии 7 – только одну палочку. На рис. 11.21 состояния 1…9 показаны в виде
                        графа состояний, вершинами которого являются состояния, а ребрами – переходы между
                        ними.`, 'p'],
                        [`В этой игре конечным состоянием всегда является 1 – проигрышное, потому что в нем нет допустимых ходов. На рис. 11.22 показана классификация состояний 1…9. Оказывается, что в этой игре все четные состояния
                        выигрышные, а все нечетные – проигрышные.
                        `, 'p'],
                        ['Игра ним', 'h1'],
                        [`Ним – простая игра, имеющая большое значение в теории игр, поскольку ту же стратегию можно применять и в других играх. Сначала мы рассмотрим ним, а затем обобщим стратегию на другие игры.`, 'p'],
                        [`В игре ним есть n кучек, и в каждой из них сколько-то палочек. Игроки
                        ходят попеременно, каждый игрок выбирает кучку, в которой еще остались палочки, и берет из нее любое число палочек. Выигрывает тот, кто
                        забирает последнюю палочку.`, 'p'],
                        [`Состояния в ним имеют вид [x1
                            , x2
                            , …, xn
                            ], где xi
                            – количество палочек в i-й
                            кучке. Так, [10, 12, 5] – состояние, в котором есть три кучки, содержащие 10,
                            12 и 5 палочек. Состояние [0, 0, …, 0] проигрышное, т. к. в нем нет возможных ходов; оно всегда является конечным.`, 'p'],
                        ['Анализ', 'h3'],
                        [`Оказывается, что состояние в ним легко классифицировать,
                        вычислив ним-сумму s = x1 ⊕ x2 ⊕ … ⊕ xn
                        , где знаком ⊕ обозначена операция ИСКЛЮЧАЮЩЕЕ ИЛИ. Состояния, в которых ним-сумма равна 0, проигрышные, остальные – выигрышные. Например, ним-сумма состояния
                        [10, 12, 5] равна 10 ⊕ 12 ⊕ 5 = 3, так что это состояние выигрышное.`, 'p'],
                        [`Но как ним-сумма связана с игрой ним? Это можно объяснить, глядя на
                        то, как меняется ним-сумма при изменении состояния игры.`, 'p'],
                        [`Конечное состояние [0, 0, …, 0] проигрышное, и
                        его ним-сумма, как и следовало ожидать, равна 0. В других проигрышных
                        состояниях любой ход приводит к выигрышному состоянию, потому что
                        при изменении одного значения xi
                        ним-сумма также изменяется, поэтому
                        после хода ним-сумма становится отлична от 0.`, 'p'],
                        [` Мы можем перейти в проигрышное состояние,
                        если существует кучка i, для которой xi ⊕ s < xi
                        . В таком случае можно забрать из кучки i столько палочек, чтобы в ней осталось xi ⊕ s палочек, а это
                        приведет к проигрышному состоянию. Такая кучка существует всегда, для
                        нее xi
                        содержит единичный бит в позиции самого левого единичного бита s.
                        `, 'p'],
                        ['Пример', 'h3'],
                        [`Рассмотрим состояние [10, 12, 5]. Это выигрышное состояние,
                        поскольку его ним-сумма равна 3. Следовательно, должен существовать
                        ход, приводящий в проигрышное состояние. Найдем такой ход.`, 'p'],
                        [`Ним-сумма состояния вычисляется следующим образом:`, 'p'],
                        [igr3, 'img'],
                        [`В данном случае кучка с 10 палочками – единственная, для которой число палочек содержит единицу в позиции самого левого единичного бита
                        ним-суммы:`, 'p'],
                        [igr4, 'img'],
                        [`Новый размер кучки должен быть равен 10 ⊕ 3 = 9, так что следует забрать всего одну палочку. После этого игра переходит в проигрышное состояние [9, 12, 5]:`, 'p'],
                        [igr5, 'img'],
                        ['Игра мизер', 'h3'],
                        [`В этом варианте игры ним цель противоположная – игрок,
                        забравший последнюю палочку, проигрывает. Оказывается, что в игре мизер оптимальная стратегия почти такая же, как в стандартной игре ним.
                        `, 'p'],
                        [`Идея в том, чтобы сначала играть в мизер как в стандартную игру, а в
                        конце игры изменить стратегию. Смена стратегии происходит в момент,
                        когда после следующего хода в каждой кучке останется не более одной палочки. В стандартной игре мы сделали бы ход, после которого осталось
                        бы четное число кучек с одной палочкой. А в игре мизер мы пойдем так,
                        чтобы число кучек с одной палочкой стало нечетным.`, 'p'],
                        [`Эта идея работает, потому что в игре обязательно имеется состояние, в
                        котором стратегию можно сменить, и это состояние выигрышное, т. к. содержит ровно одну кучку с числом палочек больше 1, поэтому его ним-сумма не равна 0.`, 'p'],
                        
                     ]}/>   













                     <Article data = {[
                        [`Преобразование Фурье`, 'h1'],
                        [`Пусть даны два полинома f(x) и g(x). В этом разделе наша задача заключается в том, чтобы эффективно вычислить произведение f(x)g(x). Например,
                        если f(x) = 2x + 3 и g(x) = 5x + 1, то искомый результат f(x)g(x) = 10x^2 + 17x + 3.
                        Простой способ вычислить произведение – перебрать все пары членов f(x)
                        и g(x) и просуммировать их произведения, как показано ниже:`, 'p'],
                        [fr1, 'img'],
                        [`Однако этот метод медленный: требуется время O(n^2), где n – степень полиномов. По счастью, произведение можно вычислить за время O(n log n),
                            воспользовавшись быстрым преобразованием Фурье (БПФ). Идея этого
                            алгоритма заключается в том, чтобы преобразовать полиномы в специальное представление значениями в точках, позволяющее упростить вычисление.
                            `, 'p'],
                        [`Работа с полиномами`, 'h1'],
                        [`Рассмотрим полином степени n – 1:`, 'p'],
                        [fr2, 'img'],
                        [`Существует два стандартных способа его представления.`, 'p'],
                        [['Представление коэффициентами: создается список'], 'ul'],
                        [fr3, 'img'],
                        [`содержащий коэффициенты полиномов.`, 'p'],
                        [['Представление значениями в точках: создается список'], 'ul'],
                        [fr4, 'img'],
                        [`содержащий значения полинома в n различных точках. Это представление основано на том, что полином степени n − 1 однозначно
                        определен значениями в n различных точках.`, 'p'],
                        [`Например, рассмотрим полином f(x) = x^3 + 2x + 5, для которого представление коэффициентами имеет вид [5, 2, 0, 3]. Чтобы создать представление
                        значениями в точках, выберем произвольно n разных точек и вычислим в
                        них полином. Одно из возможных представлений имеет вид [(0, 5), (1, 8),
                        (2, 17), (3, 38)], т. е. f(0) = 5, f(1) = 8, f(2) = 17 и f(3) = 38.`, 'p'],
                        [`У обоих способов есть достоинства. Зная представление коэффициентами, легко вычислить значение полинома в любой точке. Но для вычисления произведения полиномов f(x) и g(x) представление значениями в
                        точках удобнее: если мы знаем, что f (xi
                        ) = ai
                        и g(xi
                        ) = bi
                        в некоторой точке xi
                        ,
                        то легко вычислить f(xi
                        )g(xi
                        ) = ai
                        bi
                        . Например, если известно, что f(1) = 5 и
                        g(1) = 6, то сразу можно сказать, что f(1)g(1) = 30.`, 'p'],
                        [`Тем не менее во всех случаях, кроме вычисления произведений, мы
                        обычно предпочитаем использовать представление коэффициентами.
                        Поэтому для вычисления произведения полиномов f(x) и g(x), заданных
                        своими коэффициентами, можно поступить следующим образом:
                        `, 'p'],
                        [[
                            `создать представления f(x) и g(x) значениями в точках;`,
                            `вычислить произведение f(x)g(x) в этом представлении;`,
                            `создать представление f(x)g(x) коэффициентами.`,
                        ], 'ol'],
                        [`Заметим, что если степени f(x) и g(x) равны n − 1, то степень f(x)g(x) равна
                        2n − 2. Следовательно, на шаге 1 нужно вычислить 2n − 1 значений, чтобы
                        на шаге 3 можно было однозначно найти правильный полином.
                        `, 'p'],
                        [`Для шага 2 нужно время O(n), потому что требуется всего лишь вычислить произведение во всех точках. Шаги 1 и 3 труднее, но ниже мы покажем, как выполнить их за время O(n log n), применив алгоритм БПФ. Идея
                        в том, чтобы представить полином значениями во вполне определенных
                        точках комплексной плоскости, благодаря чему можно легко переходить
                        от одного представления к другому.`, 'p'],
                        
                     ]}/>





                     <Article data = {[
                        [`Описание`, 'h1'],
                        [`Пусть дан вектор`, 'p'], 
                        [fr5, 'img'],
                        [`представляющий полином`, 'p'],
                        [fr6, 'img'],
                        [`Тогда его преобразованием Фурье a называется вектор`, 'p'],
                        [fr7, 'img'],
                        [`где`, 'p'],
                        [fr8, 'img'],
                        [`Вектор t соответствует представлению полинома f(x) значениями в точках ω0
                        n
                        , ω1
                        n
                        , …, ωn
                        n
                        –1. Значение ωn
                        – комплексное число, называемое главным
                        корнем из единицы, это число удовлетворяет равенству ωn
                        n
                         = 1. На рисунке
                        показано положение чисел ω4
                         и ω8
                        , а также их степеней на комплексной
                        плоскости.`, 'p'],
                        [fr9, 'img'],
                        [`Алгоритм быстрого преобразования Фурье (БПФ) вычисляет преобразование Фурье за время O(n log n). Для эффективного вычисления используются свойства чисел ωn
                        . Начиная с этого момента будем предполагать,
                        что n (длина входного вектора a) – степень двойки. Если это не так, можно
                        добавить нули в конец вектора перед началом работы алгоритма.`, 'p'],
                        [fr10, 'img'],
                        [`Эта формула правильна, потому что ωk
                        n/2 = ω2
                        n
                        k
                         и ωk
                        n
                         = ωk
                        n
                        mod n
                         (см. рис. 11.28).
                        Поскольку алгоритм разбивает входной вектор длины n на два вектора
                        длины n/2 и обрабатывает их рекурсивно, время его работы составляет
                        O(n log n).`, 'p'],
                        [`Алгоритм БПФ можно также использовать для вычисления обратного
                        преобразования Фурье, т. е. для преобразования представления значениями в точках в представление коэффициентами. Удивительно, что если вычислить преобразование Фурье вектора`, 'p'],
                        [fr11, 'img'],
                        [`заменив ωn
                        на 1/ωn
                       и поделив все выходные значения на n, на выходе получится представление исходного вектора a коэффициентами.`, 'p'],
                        [`Реализация`, 'h1'],
                        [`Хорошо реализовать алгоритм БПФ не так-то просто.
                        В частности, не стоит создавать новые векторы и обрабатывать их рекурсивно, потому что при такой реализации значения постоянных множителей будут велики. Часто алгоритм рассматривается как черный ящик, который умеет эффективно вычислять преобразования Фурье, предпочитая не
                        вдаваться в детали. Показанная ниже реализация основана на псевдокоде,
                        приведенном в CLRS [7]; если вам инте ресно, что именно делает этот код,
                        обратитесь к книге.`, 'p'],
                        [`Сначала определим тип комплексного числа cd, вещественная и мнимая
                        части которого имеют тип double, а также переменную pi, равную π.`, 'p'],
                        [code18, 'code'],
                        [`Функция fft выполняет алгоритм БПФ. Ей передается вектор a, содержащий коэффициенты полинома, и дополнительный параметр d. Если d
                        равен 1 (по умолчанию), то функция вычисляет прямое преобразование
                        Фурье, а если –1, то обратное. Как уже было сказано, функция предполагает, что n – степень двойки.`, 'p'],
                        [`Сначала функция строит вектор r, равный поразрядной обратной перестановке a, соответствующей порядку, в котором производится доступ к
                        значениям на нижнем уровне рекурсии. Этот прием позволяет вычислить
                        преобразование без создания дополнительных векторов и рекурсивных
                        вызовов. После этого функция вычисляет преобразования Фурье векторов
                        длины 2, 4, 8, ..., n. Наконец, если требовалось вычислить обратное преобразование Фурье, то все выходные значения делятся на n.`, 'p'],
                        [code19, 'code'],
                        [`Ниже показано, как с помощью функции fft вычислить произведение
                        f(x) = 2x + 3 и g(x) = 5x + 1. Сначала преобразовываем оба полинома в представление значениями в точках, затем вычисляем произведение и, наконец, выполняем обратное преобразование в представление коэффициентами. Получается 10x^2 + 17x + 3, как и положено.`, 'p'],
                        [code20, 'code'],
                        [`Хотя алгоритм БПФ оперирует комплексными числами, входные и выходные значения часто являются целыми. После вычисления произведения мы можем написать (int)(p[i].real()+0.5), чтобы получить вещественную часть комплексного числа p[i] и преобразовать ее в целое.                        `, 'p'],
                        
                     ]}/>












                     <Article data = {[
                        [`Вычисление свёртки`, 'h1'],
                        [`В общем случае мы можем использовать алгоритм БПФ для вычисления
                        свертки двух массивов за время O(n log n). Если даны массивы a и b, то
                        сверткой c = a ∗ b называется массив, элементы которого вычисляются по
                        формуле`, 'p'],
                        [fr12, 'img'],
                        [`Если a и b – векторы коэффициентов двух полиномов, то свертка
                        представляет коэффициенты произведения этих полиномов, но можно
                        вычислять и свертки без всякой связи с полиномами. Приведем несколько
                        примеров.`, 'p'],
                        [`Комбинации`, 'h1'],
                        [`Имеются яблоки и бананы, у каждого плода есть вес, равный целому числу от 1 до n. Для каждого веса w ≤ 2n мы хотим узнать,
                        сколькими способами можно выбрать одно яблоко и один банан, совокупный вес которых равен w.`, 'p'],
                        [`Для решения задачи можно создать массивы a и b, так что a[i] равно числу яблок веса i, а b[i] – число бананов веса i. Тогда свертка этих массивов
                        дает искомый результат.`, 'p'],
                        [`Обработка сигнала`, 'h1'],
                        [`Можно считать, что массив a – сигнал, а массив b –
                        маска, модифицирующая этот сигнал. Маска сдвигается вдоль сигнала
                        слева направо, и в каждой позиции вычисляется сумма произведений. Результат можно вычислить как свертку, если сначала обратить маску, т. е.
                        поменять порядок элементов на противоположный.`, 'p'],
                        [`Пусть, например, a = [5, 1, 3, 4, 2, 1, 2] и b = [1, 3, 2]. Сначала создадим обращенную маску b' = [2, 3, 1], а затем вычислим свертку`, 'p'],
                        [fr13, 'img'],
                        [`На рисунке показана интерпретация значений c[1] и c[5].`],
                        [fr14, 'img'],
                        [`Разности`, 'h1'],
                        [`Дана битовая строка s длины n, требуется для каждого k = 1,
                        2, ..., n − 1 найти, сколькими способами можно выбрать две позиции i и j
                        такие, что s[i] = s[j] = 1 и j − i = k.
                        `, 'p'],
                        [`Для решения этой задачи вычислим свертку c = s ∗ s', где s' – обращение  s. Тогда элемент c[n + k − 1] дает ответ для k (можно также считать,
                            что s одно временно является сигналом и маской).`, 'p'],
                        
                     ]}/>


                </MyTabs>
            </div>
        </div>
    )
}

export default Number_theory