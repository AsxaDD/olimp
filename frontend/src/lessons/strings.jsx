import Topbar from "../baza/Topbar";
import "../css/style.css";
import React from "react";
import MyTabs from "../baza/MyTabs";
import Question from "../baza/question";
import SyntaxHightlighterPython from "../baza/CodeBlocksPython";
import Article from "../baza/CreateArticle";
import st1 from '../pics/st1.png'
import st2 from '../pics/st2.png'
import st3 from '../pics/st3.png'
import st4 from '../pics/st4.png'
import st5 from '../pics/st5.png'
import st6 from '../pics/st6.png'
import st7 from '../pics/st7.png'
import st8 from '../pics/st8.png'
import st9 from '../pics/st9.png'
import st10 from '../pics/st10.png'
import st11 from '../pics/st11.png'
import st12 from '../pics/st12.png'
import st13 from '../pics/st13.png'
import st14 from '../pics/st14.png'
import st15 from '../pics/st15.png'
import st16 from '../pics/st16.png'
import st17 from '../pics/st17.png'
import st18 from '../pics/st18.png'
import st19 from '../pics/st19.png'
import st20 from '../pics/st20.png'
import st21 from '../pics/st21.png'
import st22 from '../pics/st22.png'
import st23 from '../pics/st23.png'
import st24 from '../pics/st24.png'
import st25 from '../pics/st25.png'
import st26 from '../pics/st26.png'
import st27 from '../pics/st27.png'
import st28 from '../pics/st28.png'
import st29 from '../pics/st29.png'

const code1 = `int trie[N][A];`;
const code2 = `border[0] = 0;
for (int i = 1; i < n; i++) {
  int k = border[i-1];
  while (k != 0 && p[k] != p[i]) {
  k = border[k-1];
  }
  border[i] = (p[k] == p[i]) ? k+1 : 0;
}
`
const code3 = ``
const code4 = ``
const code5 = ``
const code6 = ``
const code7 = ``
const code8 = ``
const code9 = ``
const code10 = ``
const code11 = ``
const code12 = ``
const code13 = ``
const code14 = ``
const code15 = ``
const code16 = ``
const code17 = ``


const Strings = () => {
  return (
    <div>
      <Topbar></Topbar>

      <div style={{ maxWidth: 950, textAlign: "left", margin: "0 auto" }}>
        <h1 style={{ maxWidth: 950, marginBottom: 0, marginTop: 40 }}>Темы:</h1>
      </div>

      <div className="main__cont">
        <MyTabs themes={["Префиксное дерево", "Полиномиальное хеширование", 'Коллизии и параметры', 'Z-алгоритм', 'Суффиксные массивы', 'LCP-массивы', 'Строковые автоматы']}>

          
          <Article data = {[
            [`Базовые понятия`, 'h1'],
            [`В этой главе предполагается, что индексирование строк начинается с 0,
            т. е. строка s длины n состоит из символов s[0], s[1], …, s[n − 1].`, 'p'],
            [`Подстрокой называется последовательность соседних символов строки.
            s[a … b] обозначает подстроку, которая начинается в позиции a и заканчивается в позиции b. Префиксом называется подстрока, начинающаяся
            первым символом строки, а суффиксом – подстрока, заканчивающаяся последним символом строки.`, 'p'],
            [`Подпоследовательностью называется любая последовательность символов строки в их исходном порядке. Любая подстрока является подпоследовательностью, но обратное неверно`, 'p'],
            [st1, 'img'],
            [`Префиксное дерево`, 'h1'],
            [`Префиксным деревом (trie) называется корневое дерево для хранения
            множества строк. Каждая строка хранится в виде цепочки символов, начинающейся в корне. Если у двух строк имеется общий префикс, то у них также будет общая цепочка
            в дереве. Префиксное дерево на рисунке соответствует множеству строк {CANAL, CANDY, THE, THERE}.
            Двойной окружностью обозначены вершины, в которых некоторая строка заканчивается.`, 'p'],
            [`Построив префиксное дерево, мы можем легко
            проверить, содержит ли оно данную строку. Для
            этого нужно проследовать по цепочке, начинающейся в корневом узле. Чтобы добавить в дерево
            новую строку, нужно тоже следовать по цепочке,
            добавляя в нужных местах новые вершины. Временная сложность обеих операций равна O(n), где
            n – длина строки.`, 'p'],
            [`Префиксное дерево можно сохранить в массиве`, 'p'],
            [code1, 'code'],
            [`где N – максимальное число вершин (суммарная длина всех строк во множестве), а A – размер алфавита. Вершины дерева нумеруются числами
            0, 1, 2, … таким образом, что корень имеет номер 0, а trie[s][c] определяет
            ту вершину в цепочке, в которую мы переходим из вершины s, встретив
            символ c.`, 'p'],
            [`Структуру префиксного дерева можно обобщить несколькими способами. Пусть, например, требуется вычислить количество строк с определенным префиксом. Это можно сделать эффективно, сохранив в каждой
            вершине дерева количество строк, чьи цепочки проходят через эту вершину.`, 'p'],
            
            
          ]}/>


          <Article data = {[
            [`Хеширование строк позволяет эффективно отвечать на вопрос о равенстве
            строк, сравнивая их хеш-коды. Хеш-код – это целое число, вычисляемое
            по символам строки. Если две строки равны, то их хеш-коды тоже равны,
            благодаря чему мы можем сравнивать строки, зная хеш-коды.
            `, 'p'],
            [`Полиномиальное хеширование`, 'h1'],
            [`Чаще всего реализуют полиномиальное хеширование строк, при котором
            хеш-код строки s длины n вычисляется по формуле`, 'p'],
            [st2, 'img'],
            [`где s[0], s[1], …, s[n − 1] интерпретируются как коды символов, а A и B – заранее выбранные константы.`, 'p'],
            [`Вычислим, к примеру, хеш-код строки ABACB. Коды символов A, B и C равны 65, 66, и 67. В качестве констант выберем A = 3 и B = 97. Тогда хеш-код
            равен`, 'p'],
            [st3, 'img'],
            [`При использовании полиномиального хеширования хеш-код любой
            подстроки строки s можно вычислить за время O(1) после предобработки,
            занимающей время O(n). Идея в том, чтобы построить массив h – такой,
            что h[k] содержит хеш-код префикса s[0 … k]. Элементы массива вычисляются рекурсивно по формуле:`, 'p'],
            [st4, 'img'],
            [`Дополнительно строится массив p, для которого p[k] = A^k mod B:
            `, 'p'],
            [st5, 'img'],
            [`Для построения этих массивов требуется время O(n). После этого хешкод любой подстроки s[a … b] можно вычислить за время O(1) по формуле
            `, 'p'],
            [st6, 'img'],
            [`в предположении, что a > 0. Если a = 0, то хеш-код равен просто h[b].`, 'p'],
            [`Применения`, 'h1'],
            [`С помощью хеширования можно решить много задач, относящихся к
            строкам, потому что мы можем сравнивать произвольные подстроки
            строк за время O(1). Фактически хеширование зачастую позволяет сделать
            эффективным алгоритм полного перебора.`, 'p'],
            [`Сопоставление с образцом`, 'h3'],
            [`Фундаментальной задачей для строк
            является сопоставление с образцом: даны строка s и образец p, требуется установить, в каких позициях s встречается p. Например, образец ABC
            встречается в строке ABCABABCA в позициях 0 и 5.`, 'p'],
            [st7, 'img'],
            [`Эту задачу можно решить за время O(n
              2
              ) методом полного перебора:
              пробежаться по всем позициям s, в которых может встретиться p, и сравнить строки посимвольно.Но этот алгоритм можно сделать эффективным
              за счет хеширования, поскольку тогда каждое сравнение занимает время
              O(1). Таким образом, мы получаем алгоритм с временной сложностью O(n).`, 'p'],
            [`Различные подстроки`, 'h3'],
            [`Рассмотрим задачу о подсчете числа различных
            подстрок длины k заданной строки. Например, в строке ABABAB имеется две
            различные подстроки длины 3: ABA и BAB. Применив хеширование, мы можем вычислить хеш-коды каждой подстроки и свести задачу к подсчету числа различных целых чисел в списке, что можно сделать за время O(n log n).`, 'p'],
            [`Минимальная циклическая перестановка`, 'h3'],
            [` Циклическая перестановка строки создается путем перемещения первого символа строки в конец.
            Например, циклическими перестановками строки ATLAS являются ATLAS,
            TLASA, LASAT, ASATL и SATLA. Рассмотрим задачу о нахождении лексикографически минимальной циклической перестановки строки. Например, для
            строки ATLAS таковой является циклическая перестановка ASATL.`, 'p'],
            [`Для эффективного решения задачи мы воспользуемся комбинацией хеширования строк и двоичного поиска. Ключевая идея заключается в том,
            что определить лексикографический порядок двух строк можно за логарифмическое время. Сначала мы вычисляем длину общего префикса
            строк, применяя двоичный поиск. Здесь хеширование позволяет за время
            O(1) проверить, совпадают ли префиксы определенной длины. Затем проверяем следующий за общим префиксом символ, который и определяет
            взаимный порядок строк.
            `, 'p'],
            [`Теперь, чтобы решить задачу, мы строим строку, содержащую две расположенные подряд копии исходной строки (ATLASATLAS), и перебираем ее
            подстроки длины n, запоминая по ходу минимальную подстроку. Поскольку для одного сравнения нужно время O(log n), полная временная сложность алгоритма равна O(n log n).`, 'p'],
            [``, 'p'],
            
          ]}/>




          <Article data = {[
            [`Коллизии и параметры`, 'h1'],
            [`Очевидной опасностью при сравнении хеш-кодов является коллизия –
            ситуация, когда строки различны, но их хеш-коды совпадают. В таком
            случае алгоритм, основанный на хеш-кодах, заключает, что строки одинаковы, хотя на самом деле это не так, поэтому алгоритм может давать
            неправильные результаты.`, 'p'],
            [`Избавиться от коллизий невозможно, потому что число различных
            строк больше числа возможных хеш-кодов. Однако вероятность коллизии
            мала, если константы A и B выбраны с умом. Обычно выбирают случайные
            константы, близкие к 10^9
            , например:`, 'p'],
            [st8, 'img'],
            [`При таком выборе для вычисления хеш-кодов можно использовать тип
            long long, поскольку произведения AB и BB в него укладываются. Но достаточно ли иметь примерно 10^9
             различных хеш-кодов?`, 'p'],
            [`Рассмотрим три случая, в которых применяется хеширование.`, 'p'],
            [`Случай 1. Строки x и y сравниваются между собой. Вероятность коллизии
            равна 1/B в предположении, что все хеш-коды равновероятны.`, 'p'],
            [`Случай 2. Строка x сравнивается со строками y1
            , y2
            , ..., yn
            . Вероятность
            хотя бы одной коллизии равна`, 'p'],
            [st9, 'img'],
            [`Случай 3. Строки x1
            , x2
            , ..., xn
            сравниваются попарно. Вероятность хотя бы
            одной коллизии равна`, 'p'],
            [st10, 'img'],
            [st11, 'img'],
            [`В таблице приведены вероятности коллизий для различных значений B при n = 106
            . Как видно, в случаях 1 и 2 вероятность коллизии пренебрежимо мала, если B ≈ 109
            . Однако в случае 3 все совсем по-другому: при
            B ≈ 109 коллизия произойдет почти наверняка.`, 'p'],
            [`Ситуация в случае 3 известна под названием парадокс дней рождения:
            если в комнате находится n человек, то вероятность того, что какие-то два
            из них родились в один день, велика даже при совсем небольших n. И точно так же, когда все хеш-коды сравниваются попарно, велика вероятность,
            что какие-то два из них одинаковы.`, 'p'],
            [`Вероятность коллизии можно уменьшить, если вычислять несколько
            хеш-кодов с разными параметрами. Крайне маловероятно, что коллизия произойдет одновременно в нескольких хеш-кодах. Например, два
            хеш-кода с параметром B ≈ 10^9
             эквивалентны одному хеш-коду с параметром B ≈ 10^18, при котором вероятность коллизии очень мала.`, 'p'],
            [`ром B ≈ 10^18, при котором вероятность коллизии очень мала.
            Некоторые выбирают B = 2^32 или B = 2^64 из-за удобства операций с 32- и
            64-разрядными целыми числами по модулю 2^32 и 2^64. Но это плохой выбор,
            поскольку можно сконструировать такие входные данные, что при любой
            константе вида 2^x
             коллизии произойдут обязательно.`, 'p'],
            
          ]}/>
          
          


          <Article data = {[
            [`Z-алгоритм`, 'h1'],
            [`Далее мы опишем Z-алгоритм эффективного построения Z-массива за
            время O(n)
            1
            . Алгоритм вычисляет элементы Z-массива слева направо, при
            этом используется уже сохраненная в массиве информация и производится посимвольное сравнение строк.`, 'p'],
            [`Для эффективного вычисления элементов Z-массива алгоритм хранит
            диапазон [x, y] – такой, что s[x … y] – префикс s, значение z[x] уже определено, а значение y максимально возможное. Поскольку мы знаем, что
            s[0 … y − x] совпадает с s[x … y], то можем воспользоваться этой информацией при вычислении последующих элементов массива. Предположим,
            что уже вычислены элементы z[0], z[1], …, z[k − 1] и требуется вычислить
            z[k]. Возможны три случая.`, 'p'],
            [`Случай 1: y < k. В этом случае у нас нет информации о позиции k, поэтому
            мы вычисляем z[k], сравнивая подстроки посимвольно. Так, на рисунке
            диапазона [x, y] еще не существует, поэтому подстроки, начинающиеся в
            позициях 0 и 3, сравниваются посимвольно. Поскольку z[3] = 5, то новым
            диапазоном [x, y] становится [3, 7].`, 'p'],
            [st12, 'img'],
            [`Случай 2: y ≥ k и k + z[k − x] ≤ y. В этом случае мы знаем, что z[k] = z[k − x],
            потому что s[0 … y − x] и s[x … y] равны, и мы остаемся внутри диапазона
            [x, y]. В ситуации на рисунке мы заключаем, что z[4] = z[1] = 0`, 'p'],
            [st13, 'img'],
            [`Случай 3: y ≥ k и k + z[k − x] > y. В этом случае мы знаем, что z[k] ≥ y − k + 1.
            Однако поскольку у нас нет никакой информации после позиции y, то мы
            должны посимвольно сравнить подстроки, начинающиеся в позициях
            y − k + 1 и y + 1. Так, на рисунке мы знаем, что z[6] ≥ 2. А поскольку s[2] ≠ s[8],
            то получается, что z[6] = 2.
            `, 'p'],
            [`Этот алгоритм имеет временную сложность O(n), поскольку всякий раз,
            как при посимвольном сравнении строки два символа совпадают, значение y увеличивается. Следовательно, полное время работы, необходимое
            для сравнения подстрок, равно всего лишь O(n).`, 'p'],
            [st14, 'img'],
            ['Применения', 'h1'],
            [`Z-алгоритм предлагает альтернативный способ решения многих задач
            со строками, которые можно решить и с помощью хеширования. Но, в отличие от хеширования, Z-алгоритм всегда дает правильные результаты
            без риска коллизий. Что применять на практике – хеширование или Z-алгоритм, – зачастую дело вкуса.`, 'p'],
            [`Сопоставление с образцом`, 'h3'],
            [`. Снова рассмотрим задачу о сопоставлении
            с образцом, в которой требуется найти все вхождения образца p в строку s.
            Мы уже решили ее с помощью хеширования, а теперь посмотрим, как применить к ней Z-алгоритм`, 'p'],
            [`При обработке строк часто эксплуатируется одна и та же идея: построить строку, состоящую из нескольких частей, разделенных специальными
            символами. В данном случае мы можем построить строку p#s, где p и s
            разделены специальным символом #, не встречающимся ни в одной из
            строк. Тогда Z-массив строки p#s даст нам позиции вхождений p в s: это те
            элементы, которые содержат длину p.`, 'p'],
            [`На рисунке показан Z-массив для строки s = ABCABABCA и образца p = ABC.
            В элементах 4 и 9 находится значение 3, а это значит, что p входит в s, начиная с позиций 0 и 5.`, 'p'],
            [st15, 'img'],
            [`Нахождение границ`, 'h3'],
            [`Границей строки s называется строка b, являющаяся одновременно префиксом и суффиксом s, но не совпадающая с s.
            Например, границами строки ABACABACABA являются A, ABA и ABACABA. Все
            границы строки можно эффективно найти с помощью Z-алгоритма, потому что суффикс, начинающийся в позиции k, является границей тогда
            и только тогда, когда k + z[k] = n, где n – длина строки. Так, на рисунке
            4 + z[4] = 11, т. е. ABACABA – граница строки.`, 'p'],
            [st16, 'img'],
            
          ]}/>

          
          <Article data = {[
            [`Суффиксные массивы`, 'h1'],
            [`Суффиксный массив строки описывает лексикографический порядок ее суффиксов. Каждый элемент суффиксного массива содержит
            начальную позицию некоторого суффикса. На
            рисунке показан суффиксный массив строки
            ABAACBAB.
            `, 'p'],
            [st17, 'img'],
            [`Часто удобно располагать суффиксный массив вертикально вместе с соответствующими суффиксами
            Отметим, однако, что сам по себе суффиксный массив содержит только начальные позиции суффиксов, а не составляющие их символы.`, 'p'],
            [`Метод удвоения префикса
            `, 'h1'],
            [`Простой и эффективный способ построения суффиксного массива строки дает метод удвоения префикса, имеющий временную сложность O(n log^2 n)
            или O(n log n) в зависимости от реализации 
            . Алгоритм состоит из раундов с номерами 0, 1, …, ⌈log2
             n⌉,
            на i-м раунде обрабатываются подстроки длины 2^i
            .
            В ходе раунда каждой подстроке x длины 2^i назначается целочисленная метка l(x) – такая, что l(a) = l(b),
            тогда и только тогда, когда a = b, и l(a) < l(b) тогда и только тогда, когда a < b.`, 'p'],
            [`На раунде 0 все подстроки состоят из одного символа, и можно использовать, например, метки A = 1, B = 2 и т. д. Если же i > 0, то на i-м раунде для
            построения меток подстрок длины 2^i используются метки для подстрок
            длины 2^(i–1). Чтобы назначить метку l(x) подстроке x длины 2i
            , мы разбиваем x на две половины a и b длины 2^(i−1) с метками l(a) и l(b). (Если вторая половина начинается за пределами строки, то предполагаем, что ее метка
              равна 0.) Сначала мы назначаем в качестве начальной метки x пару (l(a),
              l(b)). После того как всем подстрокам длины 2i
               назначены начальные метки, мы сортируем эти метки и назначаем конечные метки – целые числа
              1, 2, 3 и т. д. Цель назначения конечных меток состоит в том, чтобы по завершении последнего раунда у каждой подстроки была уникальная метка,
              и эти метки отражали лексикографический порядок подстрок. И наконец,
              на основе этих меток легко построить суффиксный массив.`, 'p'],
            [`На рисунке показан процесс построения меток для строки ABAACBAB.
            После раунда 1 мы знаем, что l(AB) = 2 и l(AA) = 1. Поэтому на раунде 2 подстроке ABAA назначается начальная метка (2, 1). Поскольку существуют две
            меньшие начальные метки ((1, 6) и (2, 0)), то конечная метка будет равна
            l(ABAA) = 3. Отметим, что в этом примере после раунда 2 все метки уже
            уникальны, потому что лексикографический порядок подстрок полностью
            определен первыми четырьмя символами.`, 'p'],
            [st18, 'img'],
            [`Этот алгоритм работает за время O(n log2 n), поскольку число раундов
            равно O(log n), и на каждом раунде сортируется список n пар. На самом деле
            возможна также реализация с временной сложностью O(n log n), поскольку
            для сортировки пар можно использовать алгоритм с линейным временем.
            Тем не менее прямолинейная реализация со временем O(n log2 n), для которой не нужно ничего, кроме стандартной функции C++ sort, обычно достаточно эффективна.`, 'p'],
            [`Поиск образцов`, 'h1'],
            [`Имея суффиксный массив, можно эффективно искать все вхождения
            произвольного образца в строку. Это делается за время O(k log n), где
            n – длина строки, а k – длина образца. Идея заключается в том, чтобы обрабатывать образец символ за символом и поддерживать диапазон суффиксного массива, который соответствует уже обработанному префиксу
            образца. Чтобы эффективно обновить диапазон после обработки очередного символа, применяется двоичный поиск.`, 'p'],
            [`Найдем, например, вхождения образца BA в строку ABAACBAB.
            Первоначально диапазон поиска равен [0, 7], т. е. покрывает весь суффиксный массив. После обработки символа B диапазон сужается до [4, 6]. Наконец, после обработки символа A остается диапазон [5, 6]. Таким образом,
            мы заключаем, что образец BA входит в строку ABAACBAB дважды – начиная
            с позиций 1 и 5.`, 'p'],
            [st19, 'img'],
            [`По сравнению с хешированием строк и Z-алгоритмом, суффиксный массив имеет то преимущество, что позволяет эффективно обрабатывать несколько запросов для разных образцов, и знать эти образцы заранее при
            построении суффиксного массива необязательно.
            `, 'p'],
            
          ]}/>





          <Article data = {[
            [`LCP-массивы`, 'h1'],
            [`LCP-массив строки для каждого ее суффикса дает
            значение LCP: длину наибольшего общего префикса
            (longest common prefix) этого суффикса и следующего суффикса в суффиксном массиве. На рисунке
            показан LCP-массив для строки ABAACBAB. Например,
            значение LCP суффикса BAACBAB равно  2, поскольку
            наибольший общий префикс BAACBAB и BAB равен BA.
            Отметим, что у последнего суффикса в суффиксном
            массиве нет значения LCP`, 'p'],
            [st20, 'img'],
            [`Далее мы рассмотрим эффективный алгоритм
            построения LCP-массива строки в
            предположении, что уже построен ее суффиксный массив. Алгоритм основан на следующем наблюдении. Рассмотрим суффикс, для которого значение LCP равно x. Если удалить первый символ
            из суффикса, то значение LCP нового суффикса заведомо должно быть не
            меньше x − 1. Например, на рисунке значение LCP суффикса BAACBAB равно 2, поэтому значение LCP суффикса AACBAB должно быть не меньше 1. На
            самом деле оно в точности равно 1.`, 'p'],
            [`Воспользовавшись этим наблюдением, мы можем эффективно построить LCP-массив, вычисляя значения LCP в порядке убывания длины
            суффикса. Для каждого суффикса мы вычисляем его значение LCP, посимвольно сравнивая этот суффикс и следующий за ним в суффиксном
            массиве. Теперь воспользуемся тем фактом, что нам известно значение
            LCP суффикса, который на один символ длиннее. Следовательно, текущее
            значение LCP должно быть не меньше x − 1, где x – предыдущее значение
            LCP, и нам не нужно сравнивать первые x – 1 символов суффиксов. Получающийся алгоритм работает за время O(n), поскольку производит всего
            O(n) сравнений.
            `, 'p'],
            [`С помощью LCP-массива можно эффективно решать некоторые нетривиальные задачи со строками. Например, чтобы вычислить количество
            различных подстрок строки, мы можем просто вычесть сумму всех элементов LCP-массива из общего числа подстрок, т. е. ответ равен`, 'p'],
            [st21, 'img'],
            [`где n – длина строки, а c – сумма всех элементов LCP-массива. Например,
            в строке ABAACBAB имеется
            `, 'p'],
            [st22, 'img'],
            [`различных подстрок.`, 'p'],
            
          ]}/>
          


          <Article data = {[
            [`Строковые автоматы`, 'h1'],
            [`Автомат – это ориентированный граф, вершины которого называются
            состояниями, а ребра – переходами. Одно из состояний является начальным, оно помечается входящим ребром. Может существовать сколько
            угодно допускающих состояний, обозначаемых двойными кружками. Каждому переходу сопоставляется некоторый символ.`, 'p'],
            [`Автомат можно использовать для проверки правильности формата
            строки. Для этого мы стартуем в начальном состоянии, а затем обрабатываем символы слева направо, двигаясь по переходам. Если после обработки всей строки мы оказываемся в допускающем состоянии, то строка
            допускается, в противном случае отвергается.`, 'p'],
            [`В теории автоматов множество строк называется языком. Язык автомата
            состоит из всех допускаемых им строк. Говорят, что автомат распознает
            язык, если он допускает все строки, принадлежащие этому языку, и отвергает все прочие строки.`, 'p'],
            [`Например, автомат на рисунке допускает все строки, состоящие из
            символов A и B, в которых первый и последний символы различны, т. е.
            язык этого автомата состоит из строк вида`, 'p'],
            [st23, 'img'],
            [`В этом автомате состояние 1 начальное, а состояния 3 и 5 допускающие.
            Если на вход автомата подается строка ABB, то он проходит по цепочке
            состояний 1 → 2 → 3 → 3 и допускает строку, а если подается строка ABA, то
            он проходит по цепочке состояний 1 → 2 → 3 → 2 и отвергает строку.`, 'p'],
            [st24, 'img'],
            [`Мы предполагаем, что автоматы детерминированные, т. е. не существует
            двух переходов из одного состояния, помеченных одним и тем же символом. Это позволяет эффективно и однозначно применять автомат для
            обработки любой строки.
            `, 'p'],
            [`Автоматы для сопоставления с образцом`, 'h1'],
            [`Автомат для сопоставления с образцом можно использовать для эффективного обнаружения всех вхождений образца в строку. Идея заключается
            в том, чтобы создать автомат, допускающий строку тогда и только тогда,
            когда образец является ее суффиксом. Тогда при обработке строки автомат
            всегда переходит в допускающее состояние, если обнаружил вхождение
            образца.`, 'p'],
            [`Если задан образец p, содержащий n символов, то автомат для сопоставления с ним имеет n + 1 состояний. Состояния нумеруются числами
            0, 1, ..., n, так что состояние 0 начальное, а единственным допускающим
            является состояние n. Если мы находимся в состоянии i, то уже произвели
            сопоставление с префиксом p[0 ... i − 1], т. е. с первыми i символами образца. Далее мы переходим в состояние i + 1, если следующий входной символ
            совпадает с p[i], а в противном случае возвращаемся в какое-то состояние `, 'p'],
            [`Например, на рисунке показан автомат
            для сопоставления с образцом ABA. В процессе обработки строки ABABA он перемещается по цепочке состояний 0 → 1 → 2 →
            3 → 2 → 3. В допускающее состояние 3 он
            попадает дважды, это значит, что образец
            входит в строку два раза.`, 'p'],
            [st25, 'img'],
            [`Для построения автомата мы должны определить все переходы между
            состоя ниями. Обозначим nextState[s][c] состояние, в которое мы переходим из состояния s в результате чтения символа c. Например, на рисунке
            nextState[1][B] = 2, потому что после чтения B в состоянии 1 мы переходим в состояние 2. Оказывается, что значения nextState можно эффективно вычислить, создав сначала массив граней для образца, т. е. массив,
            в котором border[i] обозначает длину
            самой длинной (собственной) грани
            p[0 ... i]. Например, на рисунке показан массив граней образца ABAABABAAA.
            В частности, border[4] = 2, потому что
            AB – грань ABAAB максимальной длины.`, 'p'],
            [st26, 'img'],
            [`Массив граней можно построить за время O(n) следующим образом:`, 'p'],
            [code2, 'code'],
            [`Алгоритм вычисляет значения border[i], используя уже вычисленные элементы массива. Идея заключается в том, чтобы обойти грани
            p[0 ... i − 1] и выбрать самую длинную грань, которую можно расширить,
            добавив символ p[i]. Время работы алгоритма имеет порядок O(n), потому
            что border[i + 1] ≤ border[i] + 1, поэтому общее число итераций цикла while
            равно O(n).
            `, 'p'],
            [`После построения массива граней мы можем воспользоваться формулой`, 'p'],
            [st27, 'img'],
            [`для вычисления переходов. Если мы можем расширить префикс, сопоставленный в текущий момент, то переходим в следующее состояние. Если не можем и находимся в состоянии 0, то в нем и остаемся. В противном случае
            определяем самую длинную грань текущего префикса и следуем по ранее
            вычисленному переходу. Пользуясь этой формулой, мы можем построить
            автомат для сопоставления с образцом за время O(n) в предположении,
            что алфавит не изменяется.`, 'p'],
            [`Алгоритм Кнута–Морриса–Пратта – хорошо известный алгоритм
            сопоставления с образцом, основанный на моделировании автомата для
            сопоставления с образцом. Его можно рассматривать как альтернативу
            Z-алгоритму.`, 'p'],
            [`Суффиксные автоматы`, 'h1'],
            [`Суффиксным автоматом называется автомат, который допускает все
            суффиксы строки4
             и имеет минимальное число состояний. На рисунке
            показан суффиксный автомат для строки BACA. Он допускает суффиксы
            A, CA, ACA и BACA. Каждое состояние суффиксного автомата соответствует
            некоторому множеству строк, т. е. если мы находимся в этом состоянии,
            значит, произошло сопоставление с одной из строк этого множества. Например, на  рисунке состояние 3 соответствует множеству {C, AC, BAC}, а
            состояние 5 – множеству {A}. Обозначим length[x] максимальную длину
            строки в состоянии x. Тогда length[3] = 3 и length[5] = 1. Оказывается, что
            все строки в некотором состоянии являются суффиксами самой длинной
            из них, а их длины полностью покрывают диапазоны соседних целых чисел. Например, в состоянии 3 все строки являются суффиксами BAC, а их
            длины образуют диапазон 1...3.`, 'p'],
            [st28, 'img'],
            [`Для данной строки s длины n мы хотим создать ее суффиксный автомат
            за время O(n), начав с пустого автомата, имеющего только состояние 0, и
            добавив в него все символы по одному. Для этого мы будем хранить для
            каждого состояния x > 0 суффиксную ссылку link[x], указывающую на одно
            из предыдущих состояний автомата. Новый символ c добавляется в автомат следующим образом.
            `, 'p'],
            [[
              `Обозначим x текущее последнее состояние автомата, т.  е. состояние, из которого не исходит ни один переход. Создадим новое состояние y и добавим переход из x в y, помеченный c. Положим
              length[y] = length[x] + 1 и link[y] = 0.`, 
              `Следуем по суффиксным ссылкам, исходящим из x, для каждого посещенного состояния добавляем новый переход в y, помеченный c,
              пока не найдем состояние s, в которое уже ведет переход, помеченный c. Если такого состояния s нет, то завершаем работу, дойдя до
              состояния 0. В противном случае переходим к следующему шагу.
              `,
              `Обозначим u такое состояние, для которого существует переход из s
              в u, помеченный c. Если length[s] + 1 = length[u], полагаем link[y] = u
              и завершаем работу. В противном случае переходим к следующему
              шагу`,
              `Создаем новое состояние z, клонируя состояние u (копируем все исходящие из u переходы в z и полагаем link[z] = link[u]), добавляем
              переход из s в z, помеченный c, и полагаем length[z] = length[s] + 1.
              Затем полагаем link[u] = link[y] = z`,
              `Наконец, следуем по суффиксным ссылкам, исходящим из s. До тех
              пор пока из текущего состояния имеется переход в состояние u, помеченный c, заменяем u на z в этом переходе. Если мы нашли состояние, из которого нет перехода в u, помеченного c, или дошли до
              состояния 0, то завершаем работу.
              `,
            ], 'ol'],
            [`На рисунке показан процесс создания суффиксного автомата для строки BACA. После добавления последнего символа мы должны создать дополнительное состояние 5 путем клонирования состояния 2. В этом примере
            все суффиксные ссылки указывают на состояние 0, и следует ожидать, что
            в окончательном автомате существует суффиксная ссылка из состояния 4
            в состояние 5, обозначенная штриховым ребром. После создания автомата
            мы можем найти допускающие состояния, начав из последнего состояния
            и следуя по суффиксным ссылкам, пока не достигнем состояния 0. Все состояния на этом пути (в нашем примере – состояния 4 и 5) являются допускающими.`, 'p'],
            [`Заметим, что суффиксная ссылка говорит, в какое состояние мы должны
            перейти, если хотим найти более короткие строки, являющиеся суффиксами строк в текущем состоянии. В нашем примере состояние 4 соответствует множеству {CA, ACA, BACA}, а состояние 5 – множеству {A}. Таким образом,
            суффиксную ссылку из состояния 4 в состояние 5 можно использовать для
            нахождения более короткого суффикса A. На самом деле, следуя по суффиксным ссылкам из состояния x в состояние 0, мы найдем все суффиксы самой длинной строки в состоянии x, и каждый суффикс принадлежит
            ровно одному состоянию.`, 'p'],
            [`После того как суффисный автомат создан, мы можем за время O(m) проверить, встречается ли в строке любой образец длины m. Применив динамическое программирование, мы сможем также найти, сколько раз встречается образец, вычислить количество различных подстрок и т. д. В общем
            случае суффиксные автоматы могут служить альтернативой суффиксным
            массивам, и с этой новой точки зрения можно рассмотреть многие задачи
            обработки строк.`, 'p'],
            [st29, 'img'],
            
          ]}/>
         
        </MyTabs>
      </div>
    </div>
  );
};

export default Strings;
