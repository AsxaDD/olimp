import Topbar from "../baza/Topbar";
import "../css/style.css";
import React from "react";
import MyTabs from "../baza/MyTabs";
import Question from "../baza/question";
import SyntaxHightlighterPython from "../baza/CodeBlocksPython";

const fibonacciMemoization = `
# Вычисление n-ого числа Фибоначчи с помощью мемоизации

# В данном словаре будут хранится результаты вызова функции \`fib\`
mem_table = {}
    
def fib(n):
    if n == 1 or n == 2:
        return 1
        
    if not n in mem_table:
        # Если до этого мы не считали результат \`fib\` для n
        # то добавляем этот результат в таблицу мемоизации
        mem_table[n] = fib(n - 1) + fib(n - 2) 

    return mem_table[n]
`;

const fibonacciInbuiltMemoization = `
# Вычисление n-ого числа с помощью встроенной в Python мемоизации

import functools

# functools.cache предоставляет специальный декоратор для эффективной мемоизации функций
# однако для его работы требуется, чтобы ВСЕ аргументы функции могли быть хэшируемыми
# Например: list не хэшируется, вместо него необходимо использовать tuple
@functools.cache
def fib(n):
    if n == 1 or n == 2:
        return 1
        
    return fib(n - 1) + fib(n - 2)
`;

const linkedList = `
// Ячейка связанного списка
struct linked_list_node {
    // Указатель на следующую ячейку в связанном списке
    struct linked_list_node* next;
        
    // Некоторые данные, хранящиеся в каждой ячейке
    int data; 
}

    
// Связанный список
struct linked_list {
    // Указатель на начало списка
    struct linked_list_node* head;
        
    // Длинна списка
    size_t length;
}
`;

const DP = () => {
  return (
    <div>
      <Topbar></Topbar>

      <div style={{ maxWidth: 950, textAlign: "left", margin: "0 auto" }}>
        <h1 style={{ maxWidth: 950, marginBottom: 0, marginTop: 40 }}>Темы:</h1>
      </div>

      <div className="main__cont">
        <MyTabs
          themes={[
            "Основные понятия",
            "Мемоизация",
            "Рекурсия",
            "Задача о рюкзаке",
            "Задача о наибольшей общей подпоследовательности",
          ]}
        >
          <div className="flex__cont__for__articles">
            <div className="article">
              <div className="text">
                <h1>Основные понятия</h1>
                <p>
                  Динамическое программирование - способ решения сложных задач
                  путём разбиения их на более простые подзадачи. Этот способ в
                  основном применяется к задачам, которые можно явно разделить
                  на конкретные подчасти, покрывающие своим решением всю задачу.
                </p>
                <p>
                  Как правило, результаты выполнения этих "подчастей"
                  объединяются с помощью некого алгоритма, в результате которого
                  получается решение.
                </p>

                <h1>Основная идея</h1>
                <p>
                  Оптимальная подструктура в динамическом программировании
                  означает, что оптимальное решение подзадач меньшего размера
                  может быть использовано для решения исходной задачи. К
                  примеру, кратчайший путь в графе из одной вершины (обозначим
                  s) в другую (обозначим t) может быть найден так: сначала
                  считаем кратчайший путь из всех вершин, смежных с s, до t, а
                  затем, учитывая веса рёбер, которыми s соединена со смежными
                  вершинами, выбираем лучший путь до t (через какую вершину
                  лучше всего пойти).
                </p>
                <p>
                  В общем случае мы можем решить задачу, в которой присутствует
                  оптимальная подструктура, проделывая следующие три шага.
                  Разбиение задачи на подзадачи меньшего размера. Нахождение
                  оптимального решения подзадач рекурсивно, проделывая такой же
                  трехшаговый алгоритм. Использование полученного решения
                  подзадач для конструирования решения исходной задачи.
                  Подзадачи решаются делением их на подзадачи ещё меньшего
                  размера и т. д., пока не приходят к тривиальному случаю
                  задачи, решаемой за константное время (ответ можно сказать
                  сразу). К примеру, если нам нужно найти n!, то тривиальной
                  задачей будет 1! = 1 (или 0! = 1).
                </p>

                <h1>Примеры задач</h1>
                <p>
                  <ul>
                    <li>
                      <a
                        className="link"
                        href="https://en.wikipedia.org/wiki/Knapsack_problem"
                      >
                        Задача о рюкзаке (Knapsack problem)
                      </a>
                    </li>

                    <li>
                      <a
                        className="link"
                        href="https://en.wikipedia.org/wiki/Fibonacci_number"
                      >
                        Задача о вычислении чисел Фибоначчи
                      </a>
                    </li>

                    <li>
                      <a
                        className="link"
                        href="https://en.wikipedia.org/wiki/Matrix_chain_multiplication"
                      >
                        Задача о порядке перемножения матриц (Matrix chain
                        multiplication)
                      </a>
                    </li>

                    <li>
                      <a
                        className="link"
                        href="https://en.wikipedia.org/wiki/Longest_common_subsequence"
                      >
                        Задача о набольшей общей подпоследовательности (Longest
                        common subsequence)
                      </a>
                    </li>
                  </ul>
                </p>
              </div>
            </div>
          </div>

          <div>
            <div className="flex__cont__for__articles">
              <div className="article">
                <div className="text">
                  <h1>Основные понятия</h1>
                  <p>
                    Меомизация (от англ. "memory" - память и "optimization" -
                    оптимизация) - сохранение результатов выполнения функций
                    (или других исполняемых объектов) для последующего
                    использования в прогамме.
                  </p>
                  <p>
                    Позволяет за счёт использования памяти ускорить выполнение
                    программы. Часто применяется в динамическом программировании
                    для хранения промежуточных данных.
                  </p>

                  <h1>Примеры</h1>
                  <p>Все примеры приведены на языке программирования Python.</p>
                  <SyntaxHightlighterPython code={fibonacciMemoization} />
                  <SyntaxHightlighterPython
                    code={fibonacciInbuiltMemoization}
                  />
                </div>
              </div>
            </div>
          </div>

          <div className="flex__cont__for__articles">
            <div className="article">
              <div className="text">
                <h1>Основные понятия</h1>
                <p>
                  Рекурсия - это определение некого объекта с помощью самого
                  себя. В программировании самые распространённые рекурсивные
                  объекты - функции, но бывают также и рекурсивные типы данных.
                </p>
                <p>
                  Как пример рекурсии можно привести функцию, вычисляющую числа
                  Фибоначчи, которая определяется следующим образом: fib(n) =
                  fib(n-1) + fib(n+2). Или же функцию вычисления факториала
                  числа, которая определена как fac(n) = n * fac(n-1). В обоих
                  случаях n - положительное целое число.
                </p>
                <p>
                  Эрудированный читатель может подметить, что для выполнения
                  "истинной" рекурсивной функции необходимо бесконечное
                  количество памяти. К сожалению, современные ЭВМ не обладают
                  такой роскошью, ввиду чего у каждой рекурсивной функции должно
                  быть хотя бы одно условие прекращения рекурсии. Это условие
                  называется "базовым случаем" рекурсии. Например, для
                  вышеперечисленных функций базовые случаи предоставляют из себя
                  следующее: fib(1) = 1, fib(2) = 1 и fac(0) = 1.
                </p>

                <Question
                  question={"Что должно быть у каждой рекурсивной функции?"}
                  answers={[
                    "основной случай",
                    "особый случай",
                    ["базовый случай", 1],
                    "базовая компонента",
                  ]}
                />

                <h1>В типах данных</h1>
                <p>
                  Как уже было выше сказанно, рекурсия может проявляться не
                  только в определении некоторых функций, но также и в
                  определении типов данных. В низкоуровневых языках
                  программирования эта рекурсия реализвана с помощью указателей
                  на тот же тип данных, который их содержит. Ниже приведён
                  пример реализации связанного списка на C/C++.
                </p>

                <SyntaxHightlighterPython code={linkedList} />
              </div>
            </div>
          </div>
          <div className="flex__cont__for__articles">
            <div className="article">
              <div className="text">
                <h1>Краткое определение</h1>
                <p>
                  В самом простом понимании "проблема о рюкзаке" (также
                  "проблема о ранце" или "knapsack problem") представляет из
                  себя следующее: перед вами имеется рюкзак с вместимостью C
                  у.е., а так же N предметов, у каждого из которых есть объём V
                  и цена P; вам необходимо заполнить рюкзак так, чтобы сумма
                  всех P была максимальной, а сумма всех V не превышала C.
                </p>

                <p>
                  Эта проблема (и все её разновидности) - одна из самых
                  распространённых не только в информатике, но и в логистике,
                  криптографии и экономике. Скорее всего, и сам читатель не раз
                  с ней сталкивался.
                </p>

                <h1>Распространённые разновидности</h1>
                <p>
                  Ввиду большой популярности данной проблемы в разных областях
                  науки, учёные начали выделять некоторые повторяющиеся её
                  разновидности. Ниже приведены самые популярные из них, с
                  некоторыми пояснениями.
                  <ul>
                    <li>Рюкзак 0-1 - не более одного предмета каждого вида</li>
                    <li>
                      Ограниченный рюкзак - не более K предметов каждого вида
                    </li>
                    <li>
                      Неограниченный рюкзак - произвольное количество предметов
                      каждого вида
                    </li>
                    <li>И множество других..</li>
                  </ul>
                </p>

                <h1>Способы решения</h1>
                <p>
                  Наверное первое, что приходит в голову - перебрать все
                  возможные варианты "сбора рюкзака". И хотя такое решение будет
                  правильным, оно будет далеко не самым эффективным по времени.
                  Например, для того же рюкзака 0-1 подобный алгоритм будет
                  иметь сложность по времени O(2^n), где n - общее количество
                  предметов.
                </p>

                <p>
                  Можно заметить, что эта задача обладает всеми свойствами,
                  чтобы её можно было решить методом динамического
                  программирования. Именно такой метод является наиболее
                  популярным в решении данной задачи.
                </p>
              </div>
            </div>
          </div>
        </MyTabs>
      </div>
    </div>
  );
};

export default DP;
